<html> 
      <head>
        <title>GAP (ref) - Chapter 64: Lie Algebras-&gt;64.1 Lie Objects</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap64.html#X80A607C47B7A2E69"></meta>
      </head>
      <body> <h4 xmlns="http://www.w3.org/1999/xhtml">64.1 <span class="Heading">Lie Objects</span></h4><p xmlns="http://www.w3.org/1999/xhtml">Let <code class="code">x</code> be a ring element, then <code class="code">LieObject(x)</code> (seeÂ <code class="func">LieObject</code> (<a shape="rect" href="chap64_mj.html#X87F121978775AF48"><span class="RefLink">64.1-1</span></a>)) wraps <code class="code">x</code> up into an object that contains the same data (namely <code class="code">x</code>). The multiplication <code class="code">*</code> for Lie objects is formed by taking the commutator. More exactly, if <code class="code">l1</code> and <code class="code">l2</code> are the Lie objects corresponding to the ring elements <code class="code">r1</code> and <code class="code">r2</code>, then <code class="code">l1 * l2</code> is equal to the Lie object corresponding to <code class="code">r1 * r2 - r2 * r1</code>. Two rules for Lie objects are worth noting:</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>An element is <em>not</em> equal to its Lie element.</p>

</li><li><p>If we take the Lie object of an ordinary (associative) matrix then this is again a matrix; it is therefore a collection (of its rows) and a list. But it is <em>not</em> a collection of collections of its entries, and its family is <em>not</em> a collections family.</p>

</li></ul><p xmlns="http://www.w3.org/1999/xhtml">Given a family <code class="code">F</code> of ring elements, we can form its Lie family <code class="code">L</code>. The elements of <code class="code">F</code> and <code class="code">L</code> are in bijection, only the multiplications via <code class="code">*</code> differ for both families. More exactly, if <code class="code">l1</code> and <code class="code">l2</code> are the Lie elements corresponding to the elements <code class="code">f1</code> and <code class="code">f2</code> in <code class="code">F</code>, we have <code class="code">l1 * l2</code> equal to the Lie element corresponding to <code class="code">f1 * f2 - f2 * f1</code>. Furthermore, the product of Lie elements <code class="code">l1</code>, <code class="code">l2</code> and <code class="code">l3</code> is left-normed, that is <code class="code">l1*l2*l3</code> is equal to <code class="code">(l1*l2)*l3</code>.</p><p xmlns="http://www.w3.org/1999/xhtml">The main reason to distinguish elements and Lie elements on the family level is that this helps to avoid forming domains that contain elements of both types. For example, if we could form vector spaces of matrices then at first glance it would be no problem to have both ordinary and Lie matrices in it, but as soon as we find out that the space is in fact an algebra (e.g., because its dimension is that of the full matrix algebra), we would run into strange problems.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that the family situation with Lie families may be not familiar.</p><ul xmlns="http://www.w3.org/1999/xhtml"><li><p>We have to be careful when installing methods for certain types of domains that may involve Lie elements. For example, the zero element of a matrix space is either an ordinary matrix or its Lie element, depending on the space. So either the method must be aware of both cases, or the method selection must distinguish the two cases. In the latter situation, only one method may be applicable to each case; this means that it is not sufficient to treat the Lie case with the additional requirement <code class="code">IsLieObjectCollection</code> but that we must explicitly require non-Lie elements for the non-Lie case.</p>

</li><li><p>Being a full matrix space is a property that may hold for a space of ordinary matrices or a space of Lie matrices. So methods for full matrix spaces must also be aware of Lie matrices.</p>

</li></ul> </body>
    </html>