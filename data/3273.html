<html> 
      <head>
        <title>GAP (ref) - Chapter 81: An Example ‚Äì Residue Class Rings &amp;#8614; 81.3 A Second Attempt to Implement Elements of Residue Class Rings</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap81_mj.html#X85B914DD81732492"></meta>
      </head>
      <body> <h4 xmlns="http://www.w3.org/1999/xhtml">81.3 <span class="Heading">A Second Attempt to Implement Elements of Residue Class Rings</span></h4><p xmlns="http://www.w3.org/1999/xhtml">Faced with the problem to implement elements of the rings <math id="-2797431042912771151" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math>, we must define the <em>types</em> of these elements as far as is necessary to distinguish them from other <strong class="pkg">GAP</strong> objects.</p><p xmlns="http://www.w3.org/1999/xhtml">As is described in Chapter¬†<a shape="rect" href="chap13_mj.html#X7E8202627B421DB1"><span class="RefLink">13</span></a>, the type of an object comprises several aspects of information about this object; the <em>family</em> determines the relation of the object to other objects, the <em>categories</em> determine what operations the object admits, the <em>representation</em> determines how an object is actually represented, and the <em>attributes</em> describe knowledge about the object.</p><p xmlns="http://www.w3.org/1999/xhtml">First of all, we must decide about the <em>family</em> of each residue class. A natural way to do this is to put the elements of each ring <math id="4038857550701331463" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math> into a family of their own. This means that for example elements of <math id="2044251638484121679" display="inline" alttext="?/3?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mn xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">3</mn>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <cn xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml" type="integer">3</cn>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/3?</annotation>
  </semantics>
</math> and <math id="-1877758029098434960" display="inline" alttext="?/9?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mn xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">9</mn>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <cn xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml" type="integer">9</cn>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/9?</annotation>
  </semantics>
</math> lie in different families. So the only interesting relation between the families of two residue classes is equality; binary arithmetic operations with two residue classes will be admissible only if their families are equal. Note that in the naive approach in Section¬†<a shape="rect" href="chap81_mj.html#X81008A74838A792E"><span class="RefLink">81.1</span></a>, we had to take care of different moduli by a check in each function; these checks may disappear in the new approach because of our choice of families.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that we do not need to tell <strong class="pkg">GAP</strong> anything about the above decision concerning the families of the objects that we are going to implement, that is, the <em>declaration part</em> (see¬†<a shape="rect" href="chap79_mj.html#X7837CA9A83D93B38"><span class="RefLink">79.19</span></a>) of the little <strong class="pkg">GAP</strong> package we are writing contains nothing about the distribution of the new objects into families. (The actual construction of a family happens in the function <code class="code">MyZmodnZ</code> shown below.)</p><p xmlns="http://www.w3.org/1999/xhtml">Second, we want to describe methods to add or multiply two elements in <math id="799981880310804346" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math>, and these methods shall be not applicable to other <strong class="pkg">GAP</strong> objects. The natural way to do this is to create a new <em>category</em> in which all elements of all rings <math id="7594455529679432000" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math> lie. This is done as follows.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareCategory( &quot;IsMyZmodnZObj&quot;, IsScalar );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat:= CategoryCollections( IsMyZmodnZObj );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat:= CategoryCollections( cat );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cat:= CategoryCollections( cat );;</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">So all elements in the rings <math id="3983564338468385494" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math> will lie in the category <code class="code">IsMyZmodnZObj</code>, which is a subcategory of <code class="func">IsScalar</code> (<a shape="rect" href="chap31_mj.html#X8113834E84FD0435"><span class="RefLink">31.14-20</span></a>). The latter means that one can add, subtract, multiply and divide two such elements that lie in the same family, with the obvious restriction that the second operand of a division must be invertible. (The name <code class="code">IsMyZmodnZObj</code> is chosen because <code class="func">IsZmodnZObj</code> (<a shape="rect" href="chap14_mj.html#X7D0107DD79753901"><span class="RefLink">14.5-4</span></a>) is already defined in <strong class="pkg">GAP</strong>, for an implementation of residue classes that is very similar to the one developed in this manual chapter. Using this different name, one can simply enter the <strong class="pkg">GAP</strong> code of this chapter into a <strong class="pkg">GAP</strong> session, either interactively or by reading a file with this code, and experiment after each step whether the expected behaviour has been achieved, and what is still missing.)</p><p xmlns="http://www.w3.org/1999/xhtml">The next lines of <strong class="pkg">GAP</strong> code above create the categories <code class="code">CategoryCollections( IsMyZmodnZObj )</code> and two higher levels of collections categories of this, which will be needed later; it is important to create these categories before collections of the objects in <code class="code">IsMyZmodnZObj</code> actually arise.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that the only difference between <code class="func">DeclareCategory</code> (<a shape="rect" href="chap79_mj.html#X879DE2A17A6C6E92"><span class="RefLink">79.18-1</span></a>) and <code class="func">NewCategory</code> (<a shape="rect" href="chap79_mj.html#X87F68F887B44DBBD"><span class="RefLink">79.1-1</span></a>) is that in a call to <code class="func">DeclareCategory</code> (<a shape="rect" href="chap79_mj.html#X879DE2A17A6C6E92"><span class="RefLink">79.18-1</span></a>), a variable corresponding to the first argument is set to the new category, and this variable is read-only (see¬†<a shape="rect" href="chap79_mj.html#X87E29BA57C8208A4"><span class="RefLink">79.18</span></a>). The same holds for <code class="func">DeclareRepresentation</code> (<a shape="rect" href="chap79_mj.html#X7C81FB2682AE54CD"><span class="RefLink">79.18-2</span></a>) and <code class="func">NewRepresentation</code> (<a shape="rect" href="chap79_mj.html#X7CC8106F809E15CF"><span class="RefLink">79.2-1</span></a>) etc.</p><p xmlns="http://www.w3.org/1999/xhtml">There is no analogue of categories in the implementation in Section¬†<a shape="rect" href="chap81_mj.html#X81008A74838A792E"><span class="RefLink">81.1</span></a>, since there it was not necessary to distinguish residue classes from other <strong class="pkg">GAP</strong> objects. Note that the functions there assumed that their arguments were residue classes, and the user was responsible not to call them with other arguments. Thus an important aspect of types is to describe arguments of functions explicitly.</p><p xmlns="http://www.w3.org/1999/xhtml">Third, we must decide about the <em>representation</em> of our objects. This is something we know already from Section¬†<a shape="rect" href="chap81_mj.html#X81008A74838A792E"><span class="RefLink">81.1</span></a>, where we chose a list of length two. Here we may choose between two essentially different representations for the new <strong class="pkg">GAP</strong> objects, namely as &quot;component object&quot; (record-like) or &quot;positional object&quot; (list-like). We decide to store the modulus of each residue class in its family, and to encode the element <math id="889309358015574988" display="inline" alttext="k+n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">k</mi>
      <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">+</mo>
      <mrow xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
        <mo xref="p1.1.m1.1.5.1.1.cmml" id="p1.1.m1.1.5.1.1">‚Å¢</mo>
        <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
      </mrow>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <plus xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëò</ci>
        <apply xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml">
          <times xref="p1.1.m1.1.5.1.1" id="p1.1.m1.1.5.1.1.cmml"/>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
          <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
        </apply>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">k+n?</annotation>
  </semantics>
</math> by the unique residue in the range <math id="2594313441835360209" display="inline" alttext="[0..n-1]" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow id="p1.1.m1.1b">
      <mo xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" stretchy="false">[</mo>
      <mn xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">0</mn>
      <mo xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">.</mo>
      <mo xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4">.</mo>
      <mi id="p1.1.m1.1.5">n</mi>
      <mo xref="p1.1.m1.1.6.cmml" id="p1.1.m1.1.6">-</mo>
      <mn xref="p1.1.m1.1.7.cmml" id="p1.1.m1.1.7">1</mn>
      <mo xref="p1.1.m1.1.8.cmml" id="p1.1.m1.1.8" stretchy="false">]</mo>
    </mrow>
    <annotation-xml id="p1.1.m1.1c" encoding="MathML-Content">
      <cerror id="p1.1.m1.1d">
        <csymbol id="p1.1.m1.1e" cd="ambiguous">fragments</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">[</ci>
        <cn xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml" type="integer">0</cn>
        <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">.</ci>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">.</ci>
        <csymbol id="p1.1.m1.1f" cd="unknown">n</csymbol>
        <minus xref="p1.1.m1.1.6" id="p1.1.m1.1.6.cmml"/>
        <cn xref="p1.1.m1.1.7" id="p1.1.m1.1.7.cmml" type="integer">1</cn>
        <ci xref="p1.1.m1.1.8" id="p1.1.m1.1.8.cmml">]</ci>
      </cerror>
    </annotation-xml>
    <annotation id="p1.1.m1.1g" encoding="application/x-tex">[0..n-1]</annotation>
  </semantics>
</math> that is congruent to <math id="-1807608870032076483" display="inline" alttext="k" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">k</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëò</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">k</annotation>
  </semantics>
</math> modulo <math id="-5106839122441480496" display="inline" alttext="n" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">n</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëõ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">n</annotation>
  </semantics>
</math>, and the object itself is chosen to be a positional object with this residue at the first and only position (see¬†<a shape="rect" href="chap79_mj.html#X834893D07FAA6FD2"><span class="RefLink">79.11</span></a>).</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareRepresentation(&quot;IsMyModulusRep&quot;, IsPositionalObjectRep, [1]);</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">The fourth ingredients of a type, <em>attributes</em>, are usually of minor importance for element objects. In particular, we do not need to introduce special attributes for residue classes.</p><p xmlns="http://www.w3.org/1999/xhtml">Having defined what the new objects shall look like, we now declare a global function (see¬†<a shape="rect" href="chap79_mj.html#X7837CA9A83D93B38"><span class="RefLink">79.19</span></a>), to create an element when family and residue are given.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareGlobalFunction( &quot;MyZmodnZObj&quot; );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Now we have declared what we need, and we can start to implement the missing methods resp. functions; so the following command belongs to the <em>implementation part</em> of our package (see¬†<a shape="rect" href="chap79_mj.html#X7837CA9A83D93B38"><span class="RefLink">79.19</span></a>).</p><p xmlns="http://www.w3.org/1999/xhtml">The probably most interesting function is the one to construct a residue class.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallGlobalFunction( MyZmodnZObj, function( Fam, residue )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return Objectify( NewType( Fam, IsMyZmodnZObj and IsMyModulusRep ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     [ residue mod Fam!.modulus ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Note that we normalize <code class="code">residue</code> explicitly using <code class="keyw">mod</code>; we assumed that the modulus is stored in <code class="code">Fam</code>, so we must take care of this below. If <code class="code">Fam</code> is a family of residue classes, and <code class="code">residue</code> is an integer, <code class="code">MyZmodnZObj</code> returns the corresponding object in the family <code class="code">Fam</code>, which lies in the category <code class="code">IsMyZmodnZObj</code> and in the representation <code class="code">IsMyModulusRep</code>.</p><p xmlns="http://www.w3.org/1999/xhtml"><code class="code">MyZmodnZObj</code> needs an appropriate family as first argument, so let us see how to get our hands on this. Of course we could write a handy function to create such a family for given modulus, but we choose another way. In fact we do not really want to call <code class="code">MyZmodnZObj</code> explicitly when we want to create residue classes. For example, if we want to enter a matrix of residues then usually we start with a matrix of corresponding integers, and it is more elegant to do the conversion via multiplying the matrix with the identity of the required ring <math id="-4476747491576669163" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math>; this is also done for the conversion of integral matrices to finite field matrices. (Note that we will have to install a method for this.) So it is often sufficient to access this identity, for example via <code class="code">One( MyZmodnZ( <var class="Arg">n</var> ) )</code>, where <code class="code">MyZmodnZ</code> returns a domain representing the ring <math id="7692296777894360607" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math> when called with the argument <math id="-7189237701299718844" display="inline" alttext="n" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">n</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëõ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">n</annotation>
  </semantics>
</math>. We decide that constructing this ring is a natural place where the creation of the family can be hidden, and implement the function. (Note that the declaration belongs to the declaration part, and the installation belongs to the implementation part, see¬†<a shape="rect" href="chap79_mj.html#X7837CA9A83D93B38"><span class="RefLink">79.19</span></a>).</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeclareGlobalFunction( &quot;MyZmodnZ&quot; );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallGlobalFunction( MyZmodnZ, function( n )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local F, R;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   if not IsPosInt( n ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     Error( &quot;&lt;n&gt; must be a positive integer&quot; );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   # Construct the family of element objects of our ring.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   F:= NewFamily( Concatenation( &quot;MyZmod&quot;, String( n ), &quot;Z&quot; ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                  IsMyZmodnZObj );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   # Install the data.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   F!.modulus:= n;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   # Make the domain.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   R:= RingWithOneByGenerators( [ MyZmodnZObj( F, 1 ) ] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   SetIsWholeFamily( R, true );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   SetName( R, Concatenation( &quot;(Integers mod &quot;, String(n), &quot;)&quot; ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   # Return the ring.</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return R;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Note that the modulus <code class="code">n</code> is stored in the component <code class="code">modulus</code> of the family, as is assumed by <code class="code">MyZmodnZ</code>. Thus it is not necessary to store the modulus in each element. When storing <code class="code">n</code> with the <code class="code">!.</code> operator as value of the component <code class="code">modulus</code>, we used that all families are in fact represented as component objects (see¬†<a shape="rect" href="chap79_mj.html#X866E223484649E5A"><span class="RefLink">79.10</span></a>).</p><p xmlns="http://www.w3.org/1999/xhtml">We see that we can use <code class="func">RingWithOneByGenerators</code> (<a shape="rect" href="chap56_mj.html#X851115EC79B8C393"><span class="RefLink">56.3-3</span></a>) to construct a ring with one if we have the appropriate generators. The construction via <code class="func">RingWithOneByGenerators</code> (<a shape="rect" href="chap56_mj.html#X851115EC79B8C393"><span class="RefLink">56.3-3</span></a>) makes sure that <code class="func">IsRingWithOne</code> (<a shape="rect" href="chap56_mj.html#X7E601FBD8020A0F3"><span class="RefLink">56.3-1</span></a>) (and <code class="func">IsRing</code> (<a shape="rect" href="chap56_mj.html#X80FD843C8221DAC9"><span class="RefLink">56.1-1</span></a>)) is <code class="keyw">true</code> for each output of <code class="code">MyZmodnZ</code>. So the main problem is to create the identity element of the ring, which in our case suffices to generate the ring. In order to create this element via <code class="code">MyZmodnZObj</code>, we have to construct its family first, at each call of <code class="code">MyZmodnZ</code>.</p><p xmlns="http://www.w3.org/1999/xhtml">Also note that we may enter known information about the ring. Here we store that it contains the whole family of elements; this is useful for example when we want to check the membership of an element in the ring, which can be decided from the type of the element if the ring contains its whole elements family. Giving a name to the ring causes that it will be printed via printing the name. (By the way: This name <code class="code">(Integers mod <var class="Arg">n</var>)</code> looks like a call to <code class="func">\mod</code> (<a shape="rect" href="chap31_mj.html#X8481C9B97B214C23"><span class="RefLink">31.12-1</span></a>) with the arguments <code class="func">Integers</code> (<a shape="rect" href="chap14_mj.html#X853DF11B80068ED5"><span class="RefLink">14</span></a>) and <var class="Arg">n</var>; a construction of the ring via this call seems to be more natural than by calling <code class="code">MyZmodnZ</code>; later we shall install a <code class="func">\mod</code> (<a shape="rect" href="chap31_mj.html#X8481C9B97B214C23"><span class="RefLink">31.12-1</span></a>) method in order to admit this construction.)</p><p xmlns="http://www.w3.org/1999/xhtml">Now we can read the above code into <strong class="pkg">GAP</strong>, and the following works already.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R:= MyZmodnZ( 4 );</span>
(Integers mod 4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsRing( R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= GeneratorsOfRingWithOne( R );</span>
[ &lt;object&gt; ]
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">But of course this means just to ask for the information we have explicitly stored in the ring. Already the questions whether the ring is finite and how many elements it has, cannot be answered by <strong class="pkg">GAP</strong>. Clearly we know the answers, and we could store them in the ring, by setting the value of the property <code class="func">IsFinite</code> (<a shape="rect" href="chap30_mj.html#X808A4061809A6E67"><span class="RefLink">30.4-2</span></a>) to <code class="keyw">true</code> and the value of the attribute <code class="func">Size</code> (<a shape="rect" href="chap30_mj.html#X858ADA3B7A684421"><span class="RefLink">30.4-6</span></a>) to <var class="Arg">n</var> (the argument of the call to <code class="code">MyZmodnZ</code>). If we do not want to do so then <strong class="pkg">GAP</strong> could only try to find out the number of elements of the ring via forming the closure of the generators under addition and multiplication, but up to now, <strong class="pkg">GAP</strong> does not know how to add or multiply two elements of our ring.</p><p xmlns="http://www.w3.org/1999/xhtml">So we must install some methods for arithmetic and other operations if the elements are to behave as we want.</p><p xmlns="http://www.w3.org/1999/xhtml">We start with a method for showing elements nicely on the screen. There are different operations for this purpose. One of them is <code class="func">PrintObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>), which is called for each argument in an explicit call to <code class="func">Print</code> (<a shape="rect" href="chap6_mj.html#X7AFA64D97A1F39A3"><span class="RefLink">6.3-4</span></a>). Another one is <code class="func">ViewObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>), which is called in the read-eval-print loop for each object. <code class="func">ViewObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) shall produce short and human readable information about the object in question, whereas <code class="func">PrintObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) shall produce information that may be longer and is (if reasonable) readable by <strong class="pkg">GAP</strong>. We cannot satisfy the latter requirement for a <code class="func">PrintObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method because there is no way to make a family <strong class="pkg">GAP</strong> readable. So we decide to display the expression <code class="code">( k mod n )</code> for an object that is given by the residue <code class="code">k</code> and the modulus <code class="code">n</code>, which would be fine as a <code class="func">ViewObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method. Since the default for <code class="func">ViewObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) is to call <code class="func">PrintObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>), and since no other <code class="func">ViewObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method is applicable to our elements, we need only a <code class="func">PrintObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) method.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( PrintObj,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for element in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsMyZmodnZObj and IsMyModulusRep ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( x )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   Print( &quot;( &quot;, x![1], &quot; mod &quot;, FamilyObj(x)!.modulus, &quot; )&quot; );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">So we installed a method for the operation <code class="func">PrintObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) (first argument), and we gave it a suitable information message (second argument), see¬†<a shape="rect" href="chap7_mj.html#X80848FF486BD6F9F"><span class="RefLink">7.2-1</span></a> and¬†<a shape="rect" href="chap7_mj.html#X7D43A2D885B37739"><span class="RefLink">7.3</span></a> for applications of this information string. The third argument tells <strong class="pkg">GAP</strong> that the method is applicable for objects that lie in the category <code class="code">IsMyZmodnZObj</code> and in the representation <code class="code">IsMyModulusRep</code>. and the fourth argument is the method itself. More details about <code class="func">InstallMethod</code> (<a shape="rect" href="chap78_mj.html#X837EFDAB7BEF290B"><span class="RefLink">78.2-1</span></a>) can be found in¬†<a shape="rect" href="chap78_mj.html#X795EE8257848B438"><span class="RefLink">78.2</span></a>.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that the requirement <code class="code">IsMyModulusRep</code> for the argument <code class="code">x</code> allows us to access the residue as <code class="code">x![1]</code>. Since the family of <code class="code">x</code> has the component <code class="code">modulus</code> bound if it is constructed by <code class="code">MyZmodnZ</code>, we may access this component. We check whether the method installation has some effect.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens;</span>
[ ( 1 mod 4 ) ]
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Next we install methods for the comparison operations. Note that we can assume that the residues in the representation chosen are normalized.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( \=,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for two elements in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   IsIdenticalObj,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [IsMyZmodnZObj and IsMyModulusRep, IsMyZmodnZObj and IsMyModulusRep],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( x, y ) return x![1] = y![1]; end );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( \&lt;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for two elements in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   IsIdenticalObj,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [IsMyZmodnZObj and IsMyModulusRep, IsMyZmodnZObj and IsMyModulusRep],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( x, y ) return x![1] &lt; y![1]; end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">The third argument used in these installations specifies the required relation between the families of the arguments (see¬†<a shape="rect" href="chap13_mj.html#X846063757EC05986"><span class="RefLink">13.1</span></a>). This argument of a method installation, if present, is a function that shall be applied to the families of the arguments. <code class="func">IsIdenticalObj</code> (<a shape="rect" href="chap12_mj.html#X7961183378DFB902"><span class="RefLink">12.5-1</span></a>) means that the methods are applicable only if both arguments lie in the same family. (In installations for unary methods, obviously no relation is required, so this argument is left out there.)</p><p xmlns="http://www.w3.org/1999/xhtml">Up to now, we see no advantage of the new approach over the one in Section¬†<a shape="rect" href="chap81_mj.html#X81008A74838A792E"><span class="RefLink">81.1</span></a>. For a residue class represented as <code class="code">[ <var class="Arg">k</var>, <var class="Arg">n</var> ]</code>, the way it is printed on the screen is sufficient, and equality and comparison of lists are good enough to define equality and comparison of residue classes if needed. But this is not the case in other situations. For example, if we would have decided that the residue <var class="Arg">k</var> need not be normalized then we would have needed functions in Section¬†<a shape="rect" href="chap81_mj.html#X81008A74838A792E"><span class="RefLink">81.1</span></a> that compute whether two residue classes are equal, and which of two residue classes is regarded as larger than another. Note that we are free to define what &quot;larger&quot; means for objects that are newly introduced.</p><p xmlns="http://www.w3.org/1999/xhtml">Next we install methods for the arithmetic operations, first for the additive structure.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( \+,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for two elements in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   IsIdenticalObj,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [IsMyZmodnZObj and IsMyModulusRep, IsMyZmodnZObj and IsMyModulusRep],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return MyZmodnZObj( FamilyObj( x ), x![1] + y![1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( ZeroOp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for element in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsMyZmodnZObj ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   x -&gt; MyZmodnZObj( FamilyObj( x ), 0 ) );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( AdditiveInverseOp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for element in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsMyZmodnZObj and IsMyModulusRep ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   x -&gt; MyZmodnZObj( FamilyObj( x ), AdditiveInverse( x![1] ) ) );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Here the new approach starts to pay off. The method for the operation <code class="func">\+</code> (<a shape="rect" href="chap31_mj.html#X8481C9B97B214C23"><span class="RefLink">31.12-1</span></a>) allows us to use the infix operator <code class="code">+</code> for residue classes. The method for <code class="func">ZeroOp</code> (<a shape="rect" href="chap31_mj.html#X8040AC7A79FFC442"><span class="RefLink">31.10-3</span></a>) is used when we call this operation or the attribute <code class="func">Zero</code> (<a shape="rect" href="chap31_mj.html#X8040AC7A79FFC442"><span class="RefLink">31.10-3</span></a>) explicitly, and <code class="func">ZeroOp</code> (<a shape="rect" href="chap31_mj.html#X8040AC7A79FFC442"><span class="RefLink">31.10-3</span></a>) it is also used when we ask for <code class="code">0 * <var class="Arg">rescl</var></code>, where <var class="Arg">rescl</var> is a residue class.</p><p xmlns="http://www.w3.org/1999/xhtml">(Note that <code class="func">Zero</code> (<a shape="rect" href="chap31_mj.html#X8040AC7A79FFC442"><span class="RefLink">31.10-3</span></a>) and <code class="func">ZeroOp</code> (<a shape="rect" href="chap31_mj.html#X8040AC7A79FFC442"><span class="RefLink">31.10-3</span></a>) are distinguished because <code class="code">0 * <var class="Arg">obj</var></code> is guaranteed to return a <em>mutable</em> result whenever a mutable version of this result exists in <strong class="pkg">GAP</strong> ‚Äìfor example if <var class="Arg">obj</var> is a matrix‚Äì whereas <code class="func">Zero</code> (<a shape="rect" href="chap31_mj.html#X8040AC7A79FFC442"><span class="RefLink">31.10-3</span></a>) is an attribute and therefore returns <em>immutable</em> results; for our example there is no difference since the residue classes are always immutable, nevertheless we have to install the method for <code class="func">ZeroOp</code> (<a shape="rect" href="chap31_mj.html#X8040AC7A79FFC442"><span class="RefLink">31.10-3</span></a>). The same holds for <code class="func">AdditiveInverse</code> (<a shape="rect" href="chap31_mj.html#X84BB723C81D55D63"><span class="RefLink">31.10-9</span></a>), <code class="func">One</code> (<a shape="rect" href="chap31_mj.html#X8046262384895B2A"><span class="RefLink">31.10-2</span></a>), and <code class="func">Inverse</code> (<a shape="rect" href="chap31_mj.html#X78EE524E83624057"><span class="RefLink">31.10-8</span></a>).)</p><p xmlns="http://www.w3.org/1999/xhtml">Similarly, <code class="func">AdditiveInverseOp</code> (<a shape="rect" href="chap31_mj.html#X84BB723C81D55D63"><span class="RefLink">31.10-9</span></a>) can be either called directly or via the unary <code class="code">-</code> operator; so we can compute the additive inverse of the residue class <var class="Arg">rescl</var> as <code class="code">-<var class="Arg">rescl</var></code>.</p><p xmlns="http://www.w3.org/1999/xhtml">It is not necessary to install methods for subtraction, since this is handled via addition of the additive inverse of the second argument if no other method is installed.</p><p xmlns="http://www.w3.org/1999/xhtml">Let us try what we can do with the methods that are available now.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= gens[1];  y:= x + x;</span>
( 1 mod 4 )
( 2 mod 4 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">0 * x;  -x;</span>
( 0 mod 4 )
( 3 mod 4 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y = -y;  x = y;  x &lt; y;  -x &lt; y;</span>
true
false
true
false
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">We might want to admit the addition of integers and elements in rings <math id="-4864989982930332846" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math>, where an integer is implicitly identified with its residue modulo <math id="4483661348638013775" display="inline" alttext="n" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">n</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëõ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">n</annotation>
  </semantics>
</math>. To achieve this, we install methods to add an integer to an object in <code class="code">IsMyZmodnZObj</code> from the left and from the right.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( \+,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for element in Z/nZ (ModulusRep) and integer&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsMyZmodnZObj and IsMyModulusRep, IsInt ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return MyZmodnZObj( FamilyObj( x ), x![1] + y );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( \+,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for integer and element in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsInt, IsMyZmodnZObj and IsMyModulusRep ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return MyZmodnZObj( FamilyObj( y ), x + y![1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Now we can do also the following.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">2 + x;  7 - x;  y - 2;</span>
( 3 mod 4 )
( 2 mod 4 )
( 0 mod 4 )
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Similarly we install the methods dealing with the multiplicative structure. We need methods to multiply two of our objects, and to compute identity and inverse. The operation <code class="func">OneOp</code> (<a shape="rect" href="chap31_mj.html#X8046262384895B2A"><span class="RefLink">31.10-2</span></a>) is called when we ask for <code class="code"><var class="Arg">rescl</var>^0</code>, and <code class="func">InverseOp</code> (<a shape="rect" href="chap31_mj.html#X78EE524E83624057"><span class="RefLink">31.10-8</span></a>) is called when we ask for <code class="code"><var class="Arg">rescl</var>^-1</code>. Note that the method for <code class="func">InverseOp</code> (<a shape="rect" href="chap31_mj.html#X78EE524E83624057"><span class="RefLink">31.10-8</span></a>) returns <code class="keyw">fail</code> if the argument is not invertible.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( \*,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for two elements in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   IsIdenticalObj,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [IsMyZmodnZObj and IsMyModulusRep, IsMyZmodnZObj and IsMyModulusRep],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( x, y )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return MyZmodnZObj( FamilyObj( x ), x![1] * y![1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( OneOp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for element in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsMyZmodnZObj ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   elm -&gt; MyZmodnZObj( FamilyObj( elm ), 1 ) );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( InverseOp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for element in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsMyZmodnZObj and IsMyModulusRep ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( elm )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local residue;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   residue:= QuotientMod( 1, elm![1], FamilyObj( elm )!.modulus );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   if residue &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     residue:= MyZmodnZObj( FamilyObj( elm ), residue );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return residue;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">To be able to multiply our objects with integers, we need not (but we may, and we should if we are going for efficiency) install special methods. This is because in general, <strong class="pkg">GAP</strong> interprets the multiplication of an integer and an additive object as abbreviation of successive additions, and there is one generic method for such a multiplication that uses only additions and ‚Äìin the case of a negative integer‚Äì taking the additive inverse. Analogously, there is a generic method for powering by integers that uses only multiplications and taking the multiplicative inverse.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that we could also interpret the multiplication with an integer as a shorthand for the multiplication with the corresponding residue class. We are lucky that this interpretation is compatible with the one that is already available. If this would not be the case then of course we would get into trouble by installing a concurrent multiplication that computes something different from the multiplication that is already defined, since <strong class="pkg">GAP</strong> does not guarantee which of the applicable methods is actually chosen (see¬†<a shape="rect" href="chap78_mj.html#X851FC6387CA2B241"><span class="RefLink">78.3</span></a>).</p><p xmlns="http://www.w3.org/1999/xhtml">Now we have implemented methods for the arithmetic operations for our elements, and the following calculations work.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y:= 2 * x;  z:= (-5) * x;</span>
( 2 mod 4 )
( 3 mod 4 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y * z;  y * y;</span>
( 2 mod 4 )
( 0 mod 4 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">y^-1;  y^0;</span>
fail
( 1 mod 4 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z^-1;</span>
( 3 mod 4 )
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">There are some other operations in <strong class="pkg">GAP</strong> that we may want to accept our elements as arguments. An example is the operation <code class="func">Int</code> (<a shape="rect" href="chap14_mj.html#X87CA734380B5F68C"><span class="RefLink">14.2-3</span></a>) that returns, e.g., the integral part of a rational number or the integer corresponding to an element in a finite prime field. For our objects, we may define that <code class="func">Int</code> (<a shape="rect" href="chap14_mj.html#X87CA734380B5F68C"><span class="RefLink">14.2-3</span></a>) returns the normalized residue.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that we <em>define</em> this behaviour for elements but we <em>implement</em> it for objects in the representation <code class="code">IsMyModulusRep</code>. This means that if someone implements another representation of residue classes then this person must be careful to implement <code class="func">Int</code> (<a shape="rect" href="chap14_mj.html#X87CA734380B5F68C"><span class="RefLink">14.2-3</span></a>) methods for objects in this new representation compatibly with our definition, i.e., such that the result is independent of the representation.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( Int,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for element in Z/nZ (ModulusRep)&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsMyZmodnZObj and IsMyModulusRep ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   z -&gt; z![1] );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Another example of an operation for which we might want to install a method is <code class="func">\mod</code> (<a shape="rect" href="chap31_mj.html#X8481C9B97B214C23"><span class="RefLink">31.12-1</span></a>). We make the ring print itself as <code class="func">Integers</code> (<a shape="rect" href="chap14_mj.html#X853DF11B80068ED5"><span class="RefLink">14</span></a>) mod the modulus, and then it is reasonable to allow a construction this way, which makes the <code class="func">PrintObj</code> (<a shape="rect" href="chap6_mj.html#X815BF22186FD43C9"><span class="RefLink">6.3-5</span></a>) output of the ring <strong class="pkg">GAP</strong> readable.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( PrintObj,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for full collection Z/nZ&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ CategoryCollections( IsMyZmodnZObj ) and IsWholeFamily ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( R )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   Print( &quot;(Integers mod &quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          ElementsFamily( FamilyObj(R) )!.modulus, &quot;)&quot; );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( \mod,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for `Integers', and a positive integer&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsIntegers, IsPosRat and IsInt ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( Integers, n ) return MyZmodnZ( n ); end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Let us try this.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Int( y );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Integers mod 1789;</span>
(Integers mod 1789)
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Probably it is not necessary to emphasize that with the approach of Section¬†<a shape="rect" href="chap81_mj.html#X81008A74838A792E"><span class="RefLink">81.1</span></a>, installing methods for existing operations is usually not possible or at least not recommended. For example, installing the function <code class="code">resclass_sum</code> defined in Section¬†<a shape="rect" href="chap81_mj.html#X81008A74838A792E"><span class="RefLink">81.1</span></a> as a <code class="func">\+</code> (<a shape="rect" href="chap31_mj.html#X8481C9B97B214C23"><span class="RefLink">31.12-1</span></a>) method for adding two lists of length two (with integer entries) would not be compatible with the general definition of the addition of two lists of same length. Installing a method for the operation <code class="func">Int</code> (<a shape="rect" href="chap14_mj.html#X87CA734380B5F68C"><span class="RefLink">14.2-3</span></a>) that takes a list <code class="code">[ <var class="Arg">k</var>, <var class="Arg">n</var> ]</code> and returns <var class="Arg">k</var> would in principle be possible, since there is no <code class="func">Int</code> (<a shape="rect" href="chap14_mj.html#X87CA734380B5F68C"><span class="RefLink">14.2-3</span></a>) method for lists yet, but it is not sensible to do so because one can think of other interpretations of such a list where different <code class="func">Int</code> (<a shape="rect" href="chap14_mj.html#X87CA734380B5F68C"><span class="RefLink">14.2-3</span></a>) methods could be installed with the same right.</p><p xmlns="http://www.w3.org/1999/xhtml">As mentioned in Section¬†<a shape="rect" href="chap81_mj.html#X78B6425787FDB0E5"><span class="RefLink">81.2</span></a>, one advantage of the new approach is that with the implementation we have up to now, automatically also matrices of residue classes can be treated.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r:= Integers mod 16;</span>
(Integers mod 16)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">x:= One( r );</span>
( 1 mod 16 )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat:= IdentityMat( 2 ) * x;</span>
[ [ ( 1 mod 16 ), ( 0 mod 16 ) ], [ ( 0 mod 16 ), ( 1 mod 16 ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat[1][2]:= x;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat;</span>
[ [ ( 1 mod 16 ), ( 1 mod 16 ) ], [ ( 0 mod 16 ), ( 1 mod 16 ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order( mat );</span>
16
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat + mat;</span>
[ [ ( 2 mod 16 ), ( 2 mod 16 ) ], [ ( 0 mod 16 ), ( 2 mod 16 ) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last^4;</span>
[ [ ( 0 mod 16 ), ( 0 mod 16 ) ], [ ( 0 mod 16 ), ( 0 mod 16 ) ] ]
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Such matrices, if they are invertible, are valid as group elements. One technical problem is that the default algorithm for inverting matrices may give up since Gaussian elimination need not be successful over rings containing zero divisors. Therefore we install a simpleminded inversion method that inverts an integer matrix.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( InverseOp,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for an ordinary matrix over a ring Z/nZ&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ IsMatrix and IsOrdinaryMatrix</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     and CategoryCollections( CategoryCollections( IsMyZmodnZObj ) ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( mat )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local one, modulus;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   one:= One( mat[1][1] );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   modulus:= FamilyObj( one )!.modulus;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   mat:= InverseOp( List( mat, row -&gt; List( row, Int ) ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   if mat &lt;&gt; fail then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     mat:= ( mat mod modulus ) * one;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   if not IsMatrix( mat ) then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     mat:= fail;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return mat;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Additionally we install a method for finding a domain that contains the matrix entries; this is used by some <strong class="pkg">GAP</strong> library functions.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( DefaultFieldOfMatrixGroup,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    &quot;for a matrix group over a ring Z/nZ&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    [ IsMatrixGroup and CategoryCollections( CategoryCollections(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          CategoryCollections( IsMyZmodnZObj ) ) ) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    G -&gt; RingWithOneByGenerators([ One( Representative( G )[1][1] ) ]));</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Now we can deal with matrix groups over residue class rings.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2:= IdentityMat( 2 ) * x;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat2[2][1]:= x;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( mat, mat2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( g );</span>
3072
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Factors( last );</span>
[ 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">syl3:= SylowSubgroup( g, 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens:= GeneratorsOfGroup( syl3 );</span>
[ [ [ ( 1 mod 16 ), ( 7 mod 16 ) ], [ ( 11 mod 16 ), ( 14 mod 16 ) ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Order( gens[1] );</span>
3
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">It should be noted that this way more involved methods for matrix groups may not be available. For example, many questions about a finite matrix group can be delegated to an isomorphic permutation group via a so-called &quot;nice monomorphism&quot;; this can be controlled by the filter <code class="func">IsHandledByNiceMonomorphism</code> (<a shape="rect" href="chap40_mj.html#X78849F81804C44B3"><span class="RefLink">40.5-1</span></a>).</p><p xmlns="http://www.w3.org/1999/xhtml">By the way, also groups of (invertible) residue classes can be formed, but this may be of minor interest.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( x );;  Size( g );</span>
#I  default `IsGeneratorsOfMagmaWithInverses' method returns `true' for 
[ ( 1 mod 16 ) ]
1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( 3*x );;  Size( g );</span>
#I  default `IsGeneratorsOfMagmaWithInverses' method returns `true' for 
[ ( 3 mod 16 ) ]
4
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">(The messages above tell that <strong class="pkg">GAP</strong> does not know a method for deciding whether the given elements are valid group elements. We could add an appropriate <code class="code">IsGeneratorsOfMagmaWithInverses</code> method if we would want.)</p><p xmlns="http://www.w3.org/1999/xhtml">Having done enough for the elements, we may install some more methods for the rings if we want to use them as arguments. These rings are finite, and there are many generic methods that will work if they are able to compute the list of elements of the ring, so we install a method for this.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( Enumerator,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for full collection Z/nZ&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ CategoryCollections( IsMyZmodnZObj ) and IsWholeFamily ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( R )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local F;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   F:= ElementsFamily( FamilyObj(R) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return List( [ 0 .. Size( R ) - 1 ], x -&gt; MyZmodnZObj( F, x ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Note that this method is applicable only to full rings <math id="8441090022543349032" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math>, for proper subrings it would return a wrong result. Furthermore, it is not required that the argument is a ring; in fact this method is applicable also to the additive group formed by all elements in the family, provided that it knows to contain the whole family.</p><p xmlns="http://www.w3.org/1999/xhtml">Analogously, we install methods to compute the size, a random element, and the units of full rings <math id="7519516589159754504" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math>.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( Random,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for full collection Z/nZ&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ CategoryCollections( IsMyZmodnZObj ) and IsWholeFamily ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   R -&gt; MyZmodnZObj( ElementsFamily( FamilyObj(R) ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   Random( [ 0 .. Size( R ) - 1 ] ) ) );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( Size,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for full ring Z/nZ&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [ CategoryCollections( IsMyZmodnZObj ) and IsWholeFamily ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   R -&gt; ElementsFamily( FamilyObj(R) )!.modulus );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( Units,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for full ring Z/nZ&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [     CategoryCollections( IsMyZmodnZObj )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     and IsWholeFamily and IsRing ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( R )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local F;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   F:= ElementsFamily( FamilyObj( R ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return List( PrimeResidues( Size(R) ), x -&gt; MyZmodnZObj( F, x ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">The <code class="func">Units</code> (<a shape="rect" href="chap56_mj.html#X853C045B7BA6A580"><span class="RefLink">56.5-2</span></a>) method has the disadvantage that the result is returned as a list (in fact this list is also strictly sorted). We could improve the implementation by returning the units as a group; if we do not want to take the full list of elements as generators, we can use the function <code class="func">GeneratorsPrimeResidues</code> (<a shape="rect" href="chap15_mj.html#X7D191CF67E5018BE"><span class="RefLink">15.2-4</span></a>).</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallMethod( Units,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   &quot;for full ring Z/nZ&quot;,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   [     CategoryCollections( IsMyZmodnZObj )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     and IsWholeFamily and IsRing ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   function( R )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   local G, gens;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"/>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   gens:= GeneratorsPrimeResidues( Size( R ) ).generators;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   if not IsEmpty( gens ) and gens[ 1 ] = 1 then</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">     gens:= gens{ [ 2 .. Length( gens ) ] };</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   fi;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   gens:= Flat( gens ) * One( R );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   return GroupByGenerators( gens, One( R ) );</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   end );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Each ring <math id="1565661933211833828" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math> is finite, and we could install a method that returns <code class="keyw">true</code> when <code class="func">IsFinite</code> (<a shape="rect" href="chap30_mj.html#X808A4061809A6E67"><span class="RefLink">30.4-2</span></a>) is called with <math id="-4666337752604295921" display="inline" alttext="?/n?" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mrow xref="p1.1.m1.1.5.2.cmml" id="p1.1.m1.1.5.2">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">?</mi>
        <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">/</mo>
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">n</mi>
      </mrow>
      <mo xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">‚Å¢</mo>
      <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4" mathvariant="normal">?</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <times xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml"/>
        <apply xref="p1.1.m1.1.5.2" id="p1.1.m1.1.5.2.cmml">
          <divide xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">?</ci>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëõ</ci>
        </apply>
        <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">?</ci>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">?/n?</annotation>
  </semantics>
</math> as argument. But we can do this more elegantly via installing a <em>logical implication</em>.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InstallTrueMethod( IsFinite,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">   CategoryCollections( IsMyZmodnZObj ) and IsDomain );</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">In effect, every domain that consists of elements in <code class="code">IsMyZmodnZObj</code> will automatically store that it is finite, even if <code class="func">IsFinite</code> (<a shape="rect" href="chap30_mj.html#X808A4061809A6E67"><span class="RefLink">30.4-2</span></a>) is not called for it.</p> </body>
    </html>