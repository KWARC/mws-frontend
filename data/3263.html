<html> 
      <head>
        <title>GAP (ref) - Chapter 40: Group Homomorphisms-&gt;40.2 Operations for Group Homomorphisms</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap40.html#X794043AC7E4FAF9E"></meta>
      </head>
      <body> <h4 xmlns="http://www.w3.org/1999/xhtml">40.2 <span class="Heading">Operations for Group Homomorphisms</span></h4><p xmlns="http://www.w3.org/1999/xhtml">Group homomorphisms are mappings, so all the operations and properties for mappings described in chapter¬†<a shape="rect" href="chap32_mj.html#X7C9734B880042C73"><span class="RefLink">32</span></a> are applicable to them. (However often much better methods, than for general mappings are available.)</p><p xmlns="http://www.w3.org/1999/xhtml">Group homomorphisms will map groups to groups by just mapping the set of generators.</p><p xmlns="http://www.w3.org/1999/xhtml"><code class="func">KernelOfMultiplicativeGeneralMapping</code> (<a shape="rect" href="chap32_mj.html#X81A5A5CF846E5FBF"><span class="RefLink">32.9-5</span></a>) can be used to compute the kernel of a group homomorphism.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">hom:=GroupHomomorphismByImages(g,h,gens,[(1,2),(1,3)]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kernel(hom);</span>
Group([ (1,4)(2,3), (1,2)(3,4) ])
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Homomorphisms can map between groups in different representations and are also used to get isomorphic groups in a different representation.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m1:=[[0,-1],[1,0]];;m2:=[[0,-1],[1,1]];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sl2z:=Group(m1,m2);; # SL(2,Integers) as matrix group</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F:=FreeGroup(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">psl2z:=F/[F.1^2,F.2^3]; #PSL(2,Z) as FP group</span>
&lt;fp group on the generators [ f1, f2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phom:=GroupHomomorphismByImagesNC(sl2z,psl2z,[m1,m2],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">GeneratorsOfGroup(psl2z)); # the non NC-version would be expensive</span>
[ [ [ 0, -1 ], [ 1, 0 ] ], [ [ 0, -1 ], [ 1, 1 ] ] ] -&gt; [ f1, f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Kernel(phom); # the diagonal matrices</span>
Group([ [ [ -1, 0 ], [ 0, -1 ] ], [ [ -1, 0 ], [ 0, -1 ] ] ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p1:=(1,2)(3,4);;p2:=(2,4,5);;a5:=Group(p1,p2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ahom:=GroupHomomorphismByImages(psl2z,a5,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">GeneratorsOfGroup(psl2z),[p1,p2]); # here homomorphism test is cheap.</span>
[ f1, f2 ] -&gt; [ (1,2)(3,4), (2,4,5) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u:=PreImage(ahom,Group((1,2,3),(1,2)(4,5)));</span>
Group(&lt;fp, no generators known&gt;)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Index(psl2z,u);</span>
10
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">isofp:=IsomorphismFpGroup(u);; Image(isofp);</span>
&lt;fp group of size infinity on the generators [ F1, F2, F3, F4 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelatorsOfFpGroup(Image(isofp));</span>
[ F1^2, F4^2, F3^3 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">up:=PreImage(phom,u);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(GeneratorsOfGroup(up),TraceMat);</span>
[ -2, -2, 0, -4, 1, 0 ]
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">For an automorphism <var class="Arg">aut</var>, <code class="func">Inverse</code> (<a shape="rect" href="chap31_mj.html#X78EE524E83624057"><span class="RefLink">31.10-8</span></a>) returns the inverse automorphism <math id="3497301543676732971" display="inline" alttext="\textit{aut}^{{-1}}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msup xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mtext xref="p1.1.m1.1.1.1.cmml" id="p1.1.m1.1.1.1">ùëéùë¢ùë°</mtext>
      <mrow xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">
        <mo xref="p1.1.m1.1.2.1.1.cmml" id="p1.1.m1.1.2.1.1">-</mo>
        <mn xref="p1.1.m1.1.2.1.2.cmml" id="p1.1.m1.1.2.1.2">1</mn>
      </mrow>
    </msup>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">superscript</csymbol>
        <mtext xref="p1.1.m1.1.1.1" id="p1.1.m1.1.1.1.cmml">
          <span class="ltx_text ltx_font_italic" xmlns="http://www.w3.org/1999/xhtml">aut</span>
        </mtext>
        <apply xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml">
          <minus xref="p1.1.m1.1.2.1.1" id="p1.1.m1.1.2.1.1.cmml"/>
          <cn xref="p1.1.m1.1.2.1.2" id="p1.1.m1.1.2.1.2.cmml" type="integer">1</cn>
        </apply>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">\textit{aut}^{{-1}}</annotation>
  </semantics>
</math>. However if <var class="Arg">hom</var> is a bijective homomorphism between different groups, or if <var class="Arg">hom</var> is injective and considered to be a bijection to its image, the operation <code class="func">InverseGeneralMapping</code> (<a shape="rect" href="chap32_mj.html#X865FC25A87D36F3D"><span class="RefLink">32.2-3</span></a>) should be used instead. (See¬†<code class="func">Inverse</code> (<a shape="rect" href="chap31_mj.html#X78EE524E83624057"><span class="RefLink">31.10-8</span></a>) for a further discussion of this problem.)</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso:=IsomorphismPcGroup(g);</span>
Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ]) -&gt; [ f1, f2, f3, f4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Inverse(iso);</span>
#I  The mapping must be bijective and have source=range
#I  You might want to use `InverseGeneralMapping'
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">InverseGeneralMapping(iso);</span>
[ f1, f2, f3, f4 ] -&gt; Pcgs([ (3,4), (2,4,3), (1,4)(2,3), (1,3)(2,4) ])
</pre></div> </body>
    </html>