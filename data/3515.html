<html> 
      <head>
        <title>GAP (ref) - Chapter 21: Lists-&gt;21.9 Enlarging Internally Represented Lists</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap21.html#X84D6FC7E7E39ED33"></meta>
      </head>
      <body> <h4 xmlns="http://www.w3.org/1999/xhtml">21.9 <span class="Heading">Enlarging Internally Represented Lists</span></h4><p xmlns="http://www.w3.org/1999/xhtml">SectionÂ <a shape="rect" href="chap21_mj.html#X8611EF768210625B"><span class="RefLink">21.4</span></a> told you (among other things) that it is possible to assign beyond the logical end of a mutable list, automatically enlarging the list. This section tells you how this is done for internally represented lists.</p><p xmlns="http://www.w3.org/1999/xhtml">It would be extremely wasteful to make all lists large enough so that there is room for all assignments, because some lists may have more than 100000 elements, while most lists have less than 10 elements.</p><p xmlns="http://www.w3.org/1999/xhtml">On the other hand suppose every assignment beyond the end of a list would be done by allocating new space for the list and copying all entries to the new space. Then creating a list of 1000 elements by assigning them in order, would take half a million copy operations and also create a lot of garbage that the garbage collector would have to reclaim.</p><p xmlns="http://www.w3.org/1999/xhtml">So the following strategy is used. If a list is created it is created with exactly the correct size. If a list is enlarged, because of an assignment beyond the end of the list, it is enlarged by at least <code class="code"><var class="Arg">length</var>/8 + 4</code> entries. Therefore the next assignments beyond the end of the list do not need to enlarge the list. For example creating a list of 1000 elements by assigning them in order, would now take only 32 enlargements.</p><p xmlns="http://www.w3.org/1999/xhtml">The result of this is of course that the <em>physical length</em> of a list may be larger than the <em>logical length</em>, which is usually called simply the length of the list. Aside from the implications for the performance you need not be aware of the physical length. In fact all you can ever observe, for example by calling <code class="func">Length</code> (<a shape="rect" href="chap21_mj.html#X780769238600AFD1"><span class="RefLink">21.17-5</span></a>), is the logical length.</p><p xmlns="http://www.w3.org/1999/xhtml">Suppose that <code class="func">Length</code> (<a shape="rect" href="chap21_mj.html#X780769238600AFD1"><span class="RefLink">21.17-5</span></a>) would have to take the physical length and then test how many entries at the end of a list are unassigned, to compute the logical length of the list. That would take too much time. In order to make <code class="func">Length</code> (<a shape="rect" href="chap21_mj.html#X780769238600AFD1"><span class="RefLink">21.17-5</span></a>), and other functions that need to know the logical length, more efficient, the length of a list is stored along with the list.</p><p xmlns="http://www.w3.org/1999/xhtml">For fine tuning code dealing with plain lists we provide the following two functions.</p> </body>
    </html>