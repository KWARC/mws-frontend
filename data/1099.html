<html> 
      <head>
        <title>GAP (ref) - Chapter 45: Polycyclic Groups &amp;#8614; 45.17-1 ClassesSolvableGroup</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap45_mj.html#X79593F667A68A21D"></meta>
      </head>
      <body> <h5 xmlns="http://www.w3.org/1999/xhtml">45.17-1 ClassesSolvableGroup</h5><div class="func" xmlns="http://www.w3.org/1999/xhtml"><table width="100%" class="func"><tbody><tr><td colspan="1" rowspan="1" class="tdleft"><code class="func">‚Ä£ ClassesSolvableGroup</code>( <var class="Arg">G</var>, <var class="Arg">mode</var>[, <var class="Arg">opt</var>] )</td><td colspan="1" rowspan="1" class="tdright">( function )</td></tr></tbody></table></div><p xmlns="http://www.w3.org/1999/xhtml">computes conjugacy classes and centralizers in solvable groups. <var class="Arg">G</var> is the acting group. <var class="Arg">mode</var> indicates the type of the calculation:</p><p xmlns="http://www.w3.org/1999/xhtml">0 Conjugacy classes</p><p xmlns="http://www.w3.org/1999/xhtml">4 Conjugacy test for the two elements in <var class="Arg">opt</var><code class="code">.candidates</code></p><p xmlns="http://www.w3.org/1999/xhtml">In mode 0 the function returns a list of records containing components <var class="Arg">representative</var> and <var class="Arg">centralizer</var>. In mode 4 it returns a conjugating element.</p><p xmlns="http://www.w3.org/1999/xhtml">The optional record <var class="Arg">opt</var> may contain the following components that will affect the algorithm's behaviour:</p><dl xmlns="http://www.w3.org/1999/xhtml"><dt><strong class="Mark"><code class="code">pcgs</code></strong></dt><dd><p>is a pcgs that will be used for the calculation. The attribute <code class="func">EANormalSeriesByPcgs</code> (<a shape="rect" href="chap45_mj.html#X7FCE308887F621FC"><span class="RefLink">45.11-4</span></a>) must return an appropriate series of normal subgroups with elementary abelian factors among them. The algorithm will step down this series. In the case of the calculation of rational classes, it must be a pcgs refining a central series.</p>

</dd><dt><strong class="Mark"><code class="code">candidates</code></strong></dt><dd><p>is a list of elements for which canonical representatives are to be computed or for which a conjugacy test is performed. They must be given in mode 4. In mode 0 a list of classes corresponding to <code class="code">candidates</code> is returned (which may contain duplicates). The <code class="code">representative</code>s chosen are canonical with respect to <code class="code">pcgs</code>. The records returned also contain components <code class="code">operator</code> such that <code class="code">candidate ^ operator = representative</code>.</p>

</dd><dt><strong class="Mark"><code class="code">consider</code></strong></dt><dd><p>is a function <code class="code">consider( fhome, rep, cenp, K, L )</code>. Here <code class="code">fhome</code> is a home pcgs for the factor group <math id="7571960540149238720" display="inline" alttext="F" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">F</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùêπ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">F</annotation>
  </semantics>
</math> in which the calculation currently takes place, <code class="code">rep</code> is an element of the factor and <code class="code">cenp</code> is a pcgs for the centralizer of <code class="code">rep</code> modulo <code class="code">K</code>. In mode 0, when lifting from <math id="-7633211678923995377" display="inline" alttext="F" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">F</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùêπ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">F</annotation>
  </semantics>
</math>/<code class="code">K</code> to <math id="2959580365857673675" display="inline" alttext="F" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">F</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùêπ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">F</annotation>
  </semantics>
</math>/<code class="code">L</code> (note: for efficiency reasons, <math id="-2104253330199606418" display="inline" alttext="F" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">F</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùêπ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">F</annotation>
  </semantics>
</math> can be different from <var class="Arg">G</var> or <code class="code">L</code> might be not trivial) this function is called before performing the actual lifting and only those representatives for which it returns <code class="keyw">true</code> are passed to the next level. This permits for example the calculation of only those classes with small centralizers or classes of restricted orders.</p>

</dd></dl> </body>
    </html>