<html> 
      <head>
        <title>GAP (ref) - Chapter 79: Creating New Objects-&gt;79.7 Creating Families</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap79.html#X8401A9367E8CAA37"></meta>
      </head>
      <body> <h4 xmlns="http://www.w3.org/1999/xhtml">79.7 <span class="Heading">Creating Families</span></h4><p xmlns="http://www.w3.org/1999/xhtml">Families are probably the least obvious part of the <strong class="pkg">GAP</strong> type system, so some remarks about the role of families are necessary. When one uses <strong class="pkg">GAP</strong> as it is, one will (better: should) not meet families at all. The two situations where families come into play are the following.</p><p xmlns="http://www.w3.org/1999/xhtml">First, since families are used to describe relations between arguments of operations in the method selection mechanism (see Chapter <a shape="rect" href="chap78_mj.html#X8058CC8187162644"><span class="RefLink">78</span></a>, and also Chapter <a shape="rect" href="chap13_mj.html#X7E8202627B421DB1"><span class="RefLink">13</span></a>), one has to prescribe such a relation in each method installation (see <a shape="rect" href="chap78_mj.html#X795EE8257848B438"><span class="RefLink">78.2</span></a>); usual relations are <code class="func">ReturnTrue</code> (<a shape="rect" href="chap5_mj.html#X7DB422A2876CCC4D"><span class="RefLink">5.4-1</span></a>) (which means that any relation of the actual arguments is admissible), <code class="func">IsIdenticalObj</code> (<a shape="rect" href="chap12_mj.html#X7961183378DFB902"><span class="RefLink">12.5-1</span></a>) (which means that there are two arguments that lie in the same family), and <code class="code">IsCollsElms</code> (which means that there are two arguments, the first being a collection of elements that lie in the same family as the second argument).</p><p xmlns="http://www.w3.org/1999/xhtml">Second –and this is the more complicated situation– whenever one creates a new kind of objects, one has to decide what its family shall be. If the new object shall be equal to existing objects, for example if it is just represented in a different way, there is no choice: The new object must lie in the same family as all objects that shall be equal to it. So only if the new object is different (w.r.t. the equality &quot;<code class="code">=</code>&quot;) from all other <strong class="pkg">GAP</strong> objects, we are likely to create a new family for it. Note that enlarging an existing family by such new objects may be problematic because of implications that have been installed for all objects of the family in question. The choice of families depends on the applications one has in mind. For example, if the new objects in question are not likely to be arguments of operations for which family relations are relevant (for example binary arithmetic operations), one could create one family for all such objects, and regard it as &quot;the family of all those <strong class="pkg">GAP</strong> objects that would in fact not need a family&quot;. On the other extreme, if one wants to create domains of the new objects then one has to choose the family in such a way that all intended elements of a domain do in fact lie in the same family. (Remember that a domain is a collection, see Chapter <a shape="rect" href="chap12_mj.html#X7BAF69417BB925F6"><span class="RefLink">12.4</span></a>, and that a collection consists of elements in the same family, see Chapter <a shape="rect" href="chap30_mj.html#X8050A8037984E5B6"><span class="RefLink">30</span></a> and Section <a shape="rect" href="chap13_mj.html#X846063757EC05986"><span class="RefLink">13.1</span></a>.)</p><p xmlns="http://www.w3.org/1999/xhtml">Let us look at an example. Suppose that no permutations are available in <strong class="pkg">GAP</strong>, and that we want to implement permutations. Clearly we want to support permutation groups, but it is not a priori clear how to distribute the new permutations into families. We can put all permutations into one family; this is how in fact permutations are implemented in <strong class="pkg">GAP</strong>. But it would also be possible to put all permutations of a given degree into a family of their own; this would for example mean that for each degree, there would be distinguished trivial permutations, and that the stabilizer of the point <code class="code">5</code> in the symmetric group on the points <code class="code">1</code>, <code class="code">2</code>, <math id="-1010532635092701381" display="inline" alttext="\ldots" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1" mathvariant="normal">…</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">…</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">\ldots</annotation>
  </semantics>
</math>, <code class="code">5</code> is not regarded as equal to the symmetric group on <code class="code">1</code>, <code class="code">2</code>, <code class="code">3</code>, <code class="code">4</code>. Note that the latter approach would have the advantage that it is no problem to construct permutations and permutation groups acting on arbitrary (finite) sets, for example by constructing first the symmetric group on the set and then generating any desired permutation group as a subgroup of this symmetric group.</p><p xmlns="http://www.w3.org/1999/xhtml">So one aspect concerning a reasonable choice of families is to make the families large enough for being able to form interesting domains of elements in the family. But on the other hand, it is useful to choose the families small enough for admitting meaningful relations between objects. For example, the elements of different free groups in <strong class="pkg">GAP</strong> lie in different families; the multiplication of free group elements is installed only for the case that the two operands lie in the same family, with the effect that one cannot erroneously form the product of elements from different free groups. In this case, families appear as a tool for providing useful restrictions.</p><p xmlns="http://www.w3.org/1999/xhtml">As another example, note that an element and a collection containing this element never lie in the same family, by the general implementation of collections; namely, the family of a collection of elements in the family <var class="Arg">Fam</var> is the collections family of <var class="Arg">Fam</var> (see <code class="func">CollectionsFamily</code> (<a shape="rect" href="chap30_mj.html#X84E5A67E87D8DD66"><span class="RefLink">30.2-1</span></a>)). This means that for a collection, we need not (because we cannot) decide about its family.</p><p xmlns="http://www.w3.org/1999/xhtml">A few functions in <strong class="pkg">GAP</strong> return families, see <code class="func">CollectionsFamily</code> (<a shape="rect" href="chap30_mj.html#X84E5A67E87D8DD66"><span class="RefLink">30.2-1</span></a>) and <code class="func">ElementsFamily</code> (<a shape="rect" href="chap30_mj.html#X864BB3748546F63F"><span class="RefLink">30.2-3</span></a>).</p> </body>
    </html>