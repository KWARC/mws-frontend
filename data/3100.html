<html> 
      <head>
        <title>GAP (ref) - Chapter 79: Creating New Objects &amp;#8614; 79.10 Component Objects</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap79_mj.html#X866E223484649E5A"></meta>
      </head>
      <body> <h4 xmlns="http://www.w3.org/1999/xhtml">79.10 <span class="Heading">Component Objects</span></h4><p xmlns="http://www.w3.org/1999/xhtml">A <em>component object</em> is an object in the representation <code class="code">IsComponentObjectRep</code> or a subrepresentation of it. Such an object <var class="Arg">cobj</var> is built from subobjects that can be accessed via <code class="code"><var class="Arg">cobj</var>!.<var class="Arg">name</var></code>, similar to components of a record. Also analogously to records, values can be assigned to components of <var class="Arg">cobj</var> via <code class="code"><var class="Arg">cobj</var>!.<var class="Arg">name</var>:= <var class="Arg">val</var></code>. For the creation of component objects, see <a shape="rect" href="chap79_mj.html#X82E86CF37B123FD4"><span class="RefLink">79.9</span></a>. One must be <em>very careful</em> when using the <code class="code">!.</code> operator, in order to interpret the component in the right way, and even more careful when using the assignment to components using <code class="code">!.</code>, in order to keep the information stored in <var class="Arg">cobj</var> consistent.</p><p xmlns="http://www.w3.org/1999/xhtml">First of all, in the access or assignment to a component as shown above, <var class="Arg">name</var> must be among the admissible component names for the representation of <var class="Arg">cobj</var>, see <a shape="rect" href="chap79_mj.html#X7858E2848048F99D"><span class="RefLink">79.2</span></a>. Second, preferably only few low level functions should use <code class="code">!.</code>, whereas this operator should not occur in &quot;user interactions&quot;.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that even if <var class="Arg">cobj</var> claims that it is immutable, i.e., if <var class="Arg">cobj</var> is not in the category <code class="func">IsMutable</code> (<a shape="rect" href="chap12_mj.html#X7999AD1D7A4F1F46"><span class="RefLink">12.6-2</span></a>), access and assignment via <code class="code">!.</code> and <code class="code">!.:=</code> work. This is necessary for being able to store newly discovered information in immutable objects.</p><p xmlns="http://www.w3.org/1999/xhtml">The following example shows the implementation of an iterator (see <a shape="rect" href="chap30_mj.html#X85A3F00985453F95"><span class="RefLink">30.8</span></a>) for the domain of integers, which is represented as component object. See <a shape="rect" href="chap79_mj.html#X834893D07FAA6FD2"><span class="RefLink">79.11</span></a> for an implementation using positional objects. (In practice, such an iterator can be implemented more elegantly using <code class="func">IteratorByFunctions</code> (<a shape="rect" href="chap30_mj.html#X82677D8F817D6701"><span class="RefLink">30.8-8</span></a>), see <a shape="rect" href="chap79_mj.html#X7F6BF6CE7AD04EFC"><span class="RefLink">79.14</span></a>.)</p><p xmlns="http://www.w3.org/1999/xhtml">The used succession of integers is <math id="5473528176183937757" display="inline" alttext="0,1,-1,2,-2,3,-3,\ldots" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.19.1.cmml" id="p1.1.m1.1.19">
      <mn xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">0</mn>
      <mo id="p1.1.m1.1.2">,</mo>
      <mn xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">1</mn>
      <mo id="p1.1.m1.1.4">,</mo>
      <mrow xref="p1.1.m1.1.19.1.cmml" id="p1.1.m1.1.19.2">
        <mo xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">-</mo>
        <mn xref="p1.1.m1.1.6.cmml" id="p1.1.m1.1.6">1</mn>
      </mrow>
      <mo id="p1.1.m1.1.7">,</mo>
      <mn xref="p1.1.m1.1.8.cmml" id="p1.1.m1.1.8">2</mn>
      <mo id="p1.1.m1.1.9">,</mo>
      <mrow xref="p1.1.m1.1.19.1.cmml" id="p1.1.m1.1.19.3">
        <mo xref="p1.1.m1.1.10.cmml" id="p1.1.m1.1.10">-</mo>
        <mn xref="p1.1.m1.1.11.cmml" id="p1.1.m1.1.11">2</mn>
      </mrow>
      <mo id="p1.1.m1.1.12">,</mo>
      <mn xref="p1.1.m1.1.13.cmml" id="p1.1.m1.1.13">3</mn>
      <mo id="p1.1.m1.1.14">,</mo>
      <mrow xref="p1.1.m1.1.19.1.cmml" id="p1.1.m1.1.19.4">
        <mo xref="p1.1.m1.1.15.cmml" id="p1.1.m1.1.15">-</mo>
        <mn xref="p1.1.m1.1.16.cmml" id="p1.1.m1.1.16">3</mn>
      </mrow>
      <mo id="p1.1.m1.1.17">,</mo>
      <mi xref="p1.1.m1.1.18.cmml" id="p1.1.m1.1.18" mathvariant="normal">…</mi>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <list xref="p1.1.m1.1.19" id="p1.1.m1.1.19.1.cmml">
        <cn xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml" type="integer">0</cn>
        <cn xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml" type="integer">1</cn>
        <apply xref="p1.1.m1.1.19" id="p1.1.m1.1.19.2.cmml">
          <minus xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml"/>
          <cn xref="p1.1.m1.1.6" id="p1.1.m1.1.6.cmml" type="integer">1</cn>
        </apply>
        <cn xref="p1.1.m1.1.8" id="p1.1.m1.1.8.cmml" type="integer">2</cn>
        <apply xref="p1.1.m1.1.19" id="p1.1.m1.1.19.3.cmml">
          <minus xref="p1.1.m1.1.10" id="p1.1.m1.1.10.cmml"/>
          <cn xref="p1.1.m1.1.11" id="p1.1.m1.1.11.cmml" type="integer">2</cn>
        </apply>
        <cn xref="p1.1.m1.1.13" id="p1.1.m1.1.13.cmml" type="integer">3</cn>
        <apply xref="p1.1.m1.1.19" id="p1.1.m1.1.19.4.cmml">
          <minus xref="p1.1.m1.1.15" id="p1.1.m1.1.15.cmml"/>
          <cn xref="p1.1.m1.1.16" id="p1.1.m1.1.16.cmml" type="integer">3</cn>
        </apply>
        <ci xref="p1.1.m1.1.18" id="p1.1.m1.1.18.cmml">…</ci>
      </list>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">0,1,-1,2,-2,3,-3,\ldots</annotation>
  </semantics>
</math>, that is, <math id="-3865958725639016014" display="inline" alttext="a_{n}=n/2" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.7.cmml" id="p1.1.m1.1.7">
      <msub xref="p1.1.m1.1.7.1.cmml" id="p1.1.m1.1.7.1">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">a</mi>
        <mi xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">n</mi>
      </msub>
      <mo xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">=</mo>
      <mrow xref="p1.1.m1.1.7.2.cmml" id="p1.1.m1.1.7.2">
        <mi xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4">n</mi>
        <mo xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">/</mo>
        <mn xref="p1.1.m1.1.6.cmml" id="p1.1.m1.1.6">2</mn>
      </mrow>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.7" id="p1.1.m1.1.7.cmml">
        <eq xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml"/>
        <apply xref="p1.1.m1.1.7.1" id="p1.1.m1.1.7.1.cmml">
          <csymbol id="p1.1.m1.1.7.1.1.cmml" cd="ambiguous">subscript</csymbol>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">𝑎</ci>
          <ci xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml">𝑛</ci>
        </apply>
        <apply xref="p1.1.m1.1.7.2" id="p1.1.m1.1.7.2.cmml">
          <divide xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml"/>
          <ci xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">𝑛</ci>
          <cn xref="p1.1.m1.1.6" id="p1.1.m1.1.6.cmml" type="integer">2</cn>
        </apply>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">a_{n}=n/2</annotation>
  </semantics>
</math> if <math id="8796089872720571520" display="inline" alttext="n" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">n</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">𝑛</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">n</annotation>
  </semantics>
</math> is even, and <math id="5483591811650743692" display="inline" alttext="a_{n}=(1-n)/2" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.11.cmml" id="p1.1.m1.1.11">
      <msub xref="p1.1.m1.1.11.1.cmml" id="p1.1.m1.1.11.1">
        <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">a</mi>
        <mi xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">n</mi>
      </msub>
      <mo xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">=</mo>
      <mrow xref="p1.1.m1.1.11.2.cmml" id="p1.1.m1.1.11.2">
        <mrow xref="p1.1.m1.1.11.2.1.2.cmml" id="p1.1.m1.1.11.2.1">
          <mo id="p1.1.m1.1.4" stretchy="false">(</mo>
          <mrow xref="p1.1.m1.1.11.2.1.2.cmml" id="p1.1.m1.1.11.2.1.2">
            <mn xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">1</mn>
            <mo xref="p1.1.m1.1.6.cmml" id="p1.1.m1.1.6">-</mo>
            <mi xref="p1.1.m1.1.7.cmml" id="p1.1.m1.1.7">n</mi>
          </mrow>
          <mo id="p1.1.m1.1.8" stretchy="false">)</mo>
        </mrow>
        <mo xref="p1.1.m1.1.9.cmml" id="p1.1.m1.1.9">/</mo>
        <mn xref="p1.1.m1.1.10.cmml" id="p1.1.m1.1.10">2</mn>
      </mrow>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.11" id="p1.1.m1.1.11.cmml">
        <eq xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml"/>
        <apply xref="p1.1.m1.1.11.1" id="p1.1.m1.1.11.1.cmml">
          <csymbol id="p1.1.m1.1.11.1.1.cmml" cd="ambiguous">subscript</csymbol>
          <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">𝑎</ci>
          <ci xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml">𝑛</ci>
        </apply>
        <apply xref="p1.1.m1.1.11.2" id="p1.1.m1.1.11.2.cmml">
          <divide xref="p1.1.m1.1.9" id="p1.1.m1.1.9.cmml"/>
          <apply xref="p1.1.m1.1.11.2.1" id="p1.1.m1.1.11.2.1.2.cmml">
            <minus xref="p1.1.m1.1.6" id="p1.1.m1.1.6.cmml"/>
            <cn xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml" type="integer">1</cn>
            <ci xref="p1.1.m1.1.7" id="p1.1.m1.1.7.cmml">𝑛</ci>
          </apply>
          <cn xref="p1.1.m1.1.10" id="p1.1.m1.1.10.cmml" type="integer">2</cn>
        </apply>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">a_{n}=(1-n)/2</annotation>
  </semantics>
</math> otherwise.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
IsIntegersIteratorCompRep := NewRepresentation( &quot;IsIntegersIteratorRep&quot;,
    IsComponentObjectRep, [ &quot;counter&quot; ] );
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">The above command creates a new representation (see <code class="func">NewRepresentation</code> (<a shape="rect" href="chap79_mj.html#X7CC8106F809E15CF"><span class="RefLink">79.2-1</span></a>)) <code class="code">IsIntegersIteratorCompRep</code>, as a subrepresentation of <code class="code">IsComponentObjectRep</code>, and with one admissible component <code class="code">counter</code>. So no other components than <code class="code">counter</code> will be needed.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
InstallMethod( Iterator,
    &quot;method for `Integers'&quot;,
    [ IsIntegers ],
    function( Integers )
    return Objectify( NewType( IteratorsFamily,
                                   IsIterator
                               and IsIntegersIteratorCompRep ),
                      rec( counter := 0 ) );
    end );
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">After the above method installation, one can already ask for <code class="code">Iterator( Integers )</code>. Note that exactly the domain of integers is described by the filter <code class="func">IsIntegers</code> (<a shape="rect" href="chap14_mj.html#X818683B17F8C97F3"><span class="RefLink">14.1-2</span></a>).</p><p xmlns="http://www.w3.org/1999/xhtml">By the call to <code class="func">NewType</code> (<a shape="rect" href="chap79_mj.html#X7CE39E9478AEC826"><span class="RefLink">79.8-1</span></a>), the returned object lies in the family containing all iterators, which is <code class="code">IteratorsFamily</code>, it lies in the category <code class="func">IsIterator</code> (<a shape="rect" href="chap30_mj.html#X87168A827E5B28E4"><span class="RefLink">30.8-3</span></a>) and in the representation <code class="code">IsIntegersIteratorCompRep</code>; furthermore, it has the component <code class="code">counter</code> with value <code class="code">0</code>.</p><p xmlns="http://www.w3.org/1999/xhtml">What is missing now are methods for the two basic operations of iterators, namely <code class="func">IsDoneIterator</code> (<a shape="rect" href="chap30_mj.html#X8055FC557B5D899E"><span class="RefLink">30.8-4</span></a>) and <code class="func">NextIterator</code> (<a shape="rect" href="chap30_mj.html#X879F62F77D1D1179"><span class="RefLink">30.8-5</span></a>). The former must always return <code class="keyw">false</code>, since there are infinitely many integers. The latter must return the next integer in the iteration, and update the information stored in the iterator, that is, increase the value of the component <code class="code">counter</code>.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
InstallMethod( IsDoneIterator,
    &quot;method for iterator of `Integers'&quot;,
    [ IsIterator and IsIntegersIteratorCompRep ],
    ReturnFalse );

InstallMethod( NextIterator,
    &quot;method for iterator of `Integers'&quot;,
    [ IsIntegersIteratorCompRep ],
    function( iter )
    iter!.counter:= iter!.counter + 1;
    if iter!.counter mod 2 = 0 then
      return iter!.counter / 2;
    else
      return ( 1 - iter!.counter ) / 2;
    fi;
    end );
</pre></div> </body>
    </html>