<html> 
      <head>
        <title>GAP (ref) - Chapter 48: Presentations and Tietze Transformations &amp;#8614; 48.10-1 DecodeTree</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap48_mj.html#X7ACBFE2F78D72A31"></meta>
      </head>
      <body> <h5 xmlns="http://www.w3.org/1999/xhtml">48.10-1 DecodeTree</h5><div class="func" xmlns="http://www.w3.org/1999/xhtml"><table width="100%" class="func"><tbody><tr><td colspan="1" rowspan="1" class="tdleft"><code class="func">‚Ä£ DecodeTree</code>( <var class="Arg">P</var> )</td><td colspan="1" rowspan="1" class="tdright">( function )</td></tr></tbody></table></div><p xmlns="http://www.w3.org/1999/xhtml">assumes that <var class="Arg">P</var> is a subgroup presentation provided by the Reduced Reidemeister-Schreier or by the Modified Todd-Coxeter method (see <code class="func">PresentationSubgroupRrs</code> (<a shape="rect" href="chap48_mj.html#X857365CD87ADC29E"><span class="RefLink">48.2-2</span></a>), <code class="func">PresentationNormalClosureRrs</code> (<a shape="rect" href="chap48_mj.html#X7D6A52837BEE5C3D"><span class="RefLink">48.2-5</span></a>), <code class="func">PresentationSubgroupMtc</code> (<a shape="rect" href="chap48_mj.html#X80BA10F780EAE68E"><span class="RefLink">48.2-4</span></a>)). It eliminates the secondary generators of <var class="Arg">P</var> (see Section <a shape="rect" href="chap48_mj.html#X8118FECE7AD1879B"><span class="RefLink">48.2</span></a>) by applying the so called &quot;decoding tree&quot; procedure.</p><p xmlns="http://www.w3.org/1999/xhtml"><code class="func">DecodeTree</code> is called automatically by the command <code class="func">PresentationSubgroupMtc</code> (<a shape="rect" href="chap48_mj.html#X80BA10F780EAE68E"><span class="RefLink">48.2-4</span></a>) where it reduces <var class="Arg">P</var> to a presentation on the given (primary) subgroup generators.</p><p xmlns="http://www.w3.org/1999/xhtml">In order to explain the effect of this command we need to insert a few remarks on the subgroup presentation commands described in section <a shape="rect" href="chap48_mj.html#X8118FECE7AD1879B"><span class="RefLink">48.2</span></a>. All these commands have the common property that in the process of constructing a presentation for a given subgroup <var class="Arg">H</var> of a finitely presented group <var class="Arg">G</var> they first build up a highly redundant list of generators of <var class="Arg">H</var> which consists of an (in general small) list of &quot;primary&quot; generators, followed by an (in general large) list of &quot;secondary&quot; generators, and then construct a presentation <math id="7631269712818445990" display="inline" alttext="P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msub xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mn xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">0</mn>
    </msub>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">subscript</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <cn xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml" type="integer">0</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P_{0}</annotation>
  </semantics>
</math>, say, <em>on a sublist of these generators</em> by rewriting the defining relators of <var class="Arg">G</var>. This sublist contains all primary, but, at least in general, by far not all secondary generators.</p><p xmlns="http://www.w3.org/1999/xhtml">The role of the primary generators depends on the concrete choice of the subgroup presentation command. If the Modified Todd-Coxeter method is used, they are just the given generators of <var class="Arg">H</var>, whereas in the case of the Reduced Reidemeister-Schreier algorithm they are constructed by the program.</p><p xmlns="http://www.w3.org/1999/xhtml">Each of the secondary generators is defined by a word of length two in the preceding generators and their inverses. By historical reasons, the list of these definitions is called the <em>subgroup generators tree</em> though in fact it is not a tree but rather a kind of bush.</p><p xmlns="http://www.w3.org/1999/xhtml">Now we have to distinguish two cases. If <math id="6186211629582356187" display="inline" alttext="P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msub xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mn xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">0</mn>
    </msub>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">subscript</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <cn xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml" type="integer">0</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P_{0}</annotation>
  </semantics>
</math> has been constructed by the Reduced Reidemeister-Schreier routines, it is a presentation of <var class="Arg">H</var>. However, if the Modified Todd-Coxeter routines have been used instead, then the relators in <math id="6742750455542544617" display="inline" alttext="P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msub xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mn xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">0</mn>
    </msub>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">subscript</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <cn xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml" type="integer">0</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P_{0}</annotation>
  </semantics>
</math> are valid relators of <var class="Arg">H</var>, but they do not necessarily define <var class="Arg">H</var>. We handle these cases in turn, starting with the latter one.</p><p xmlns="http://www.w3.org/1999/xhtml">In fact, we could easily receive a presentation of <var class="Arg">H</var> also in this case if we extended <math id="-8004772999496273609" display="inline" alttext="P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msub xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mn xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">0</mn>
    </msub>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">subscript</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <cn xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml" type="integer">0</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P_{0}</annotation>
  </semantics>
</math> by adding to it all the secondary generators which are not yet contained in it and all the definitions from the generators tree as additional generators and relators. Then we could recursively eliminate all secondary generators by Tietze transformations using the new relators. However, this procedure turns out to be too inefficient to be of interest.</p><p xmlns="http://www.w3.org/1999/xhtml">Instead, we use the so called <em>decoding tree</em> procedure (see <a shape="rect" href="chapBib_mj.html#biBAMW82">[AMW82]</a>, <a shape="rect" href="chapBib_mj.html#biBAR84">[AR84]</a>). It proceeds as follows.</p><p xmlns="http://www.w3.org/1999/xhtml">Starting from <math id="-9006699391561234631" display="inline" alttext="P=P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">=</mo>
      <msub xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">P</mi>
        <mn xref="p1.1.m1.1.4.1.cmml" id="p1.1.m1.1.4.1">0</mn>
      </msub>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <eq xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <apply xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml">
          <csymbol id="p1.1.m1.1.5.1.1.cmml" cd="ambiguous">subscript</csymbol>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëÉ</ci>
          <cn xref="p1.1.m1.1.4.1" id="p1.1.m1.1.4.1.cmml" type="integer">0</cn>
        </apply>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P=P_{0}</annotation>
  </semantics>
</math>, it runs through a number of steps in each of which it eliminates the current &quot;last&quot; generator (with respect to the list of all primary and secondary generators). If the last generator <var class="Arg">g</var>, say, is a primary generator, then the procedure terminates. Otherwise it checks whether there is a relator in the current presentation which can be used to substitute <var class="Arg">g</var> by a Tietze transformation. If so, this is done. Otherwise, and only then, the tree definition of <var class="Arg">g</var> is added to <var class="Arg">P</var> as a new relator, and the generators involved are added as new generators if they have not yet been contained in <var class="Arg">P</var>. Subsequently, <var class="Arg">g</var> is eliminated.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that the extension of <var class="Arg">P</var> by one or two new generators is <em>not</em> a Tietze transformation. In general, it will change the isomorphism type of the group defined by <var class="Arg">P</var>. However, it is a remarkable property of this procedure, that at the end, i.e., as soon as all secondary generators have been eliminated, it provides a presentation <math id="-718562743311298108" display="inline" alttext="P=P_{1}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mrow xref="p1.1.m1.1.5.cmml" id="p1.1.m1.1.5">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mo xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">=</mo>
      <msub xref="p1.1.m1.1.5.1.cmml" id="p1.1.m1.1.5.1">
        <mi xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">P</mi>
        <mn xref="p1.1.m1.1.4.1.cmml" id="p1.1.m1.1.4.1">1</mn>
      </msub>
    </mrow>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.5" id="p1.1.m1.1.5.cmml">
        <eq xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml"/>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <apply xref="p1.1.m1.1.5.1" id="p1.1.m1.1.5.1.cmml">
          <csymbol id="p1.1.m1.1.5.1.1.cmml" cd="ambiguous">subscript</csymbol>
          <ci xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">ùëÉ</ci>
          <cn xref="p1.1.m1.1.4.1" id="p1.1.m1.1.4.1.cmml" type="integer">1</cn>
        </apply>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P=P_{1}</annotation>
  </semantics>
</math>, say, which defines a group isomorphic to <var class="Arg">H</var>. In fact, it is this presentation which is returned by the command <code class="func">DecodeTree</code> and hence by the command <code class="func">PresentationSubgroupMtc</code> (<a shape="rect" href="chap48_mj.html#X80BA10F780EAE68E"><span class="RefLink">48.2-4</span></a>).</p><p xmlns="http://www.w3.org/1999/xhtml">If, in the other case, the presentation <math id="-6756811328413752317" display="inline" alttext="P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msub xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mn xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">0</mn>
    </msub>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">subscript</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <cn xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml" type="integer">0</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P_{0}</annotation>
  </semantics>
</math> has been constructed by the Reduced Reidemeister-Schreier algorithm, then <math id="3833523162883320500" display="inline" alttext="P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msub xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mn xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">0</mn>
    </msub>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">subscript</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <cn xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml" type="integer">0</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P_{0}</annotation>
  </semantics>
</math> itself is a presentation of <var class="Arg">H</var>, and the corresponding subgroup presentation command (<code class="func">PresentationSubgroupRrs</code> (<a shape="rect" href="chap48_mj.html#X857365CD87ADC29E"><span class="RefLink">48.2-2</span></a>) or <code class="func">PresentationNormalClosureRrs</code> (<a shape="rect" href="chap48_mj.html#X7D6A52837BEE5C3D"><span class="RefLink">48.2-5</span></a>)) just returns <math id="258636693395433268" display="inline" alttext="P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msub xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mn xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">0</mn>
    </msub>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">subscript</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <cn xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml" type="integer">0</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P_{0}</annotation>
  </semantics>
</math>.</p><p xmlns="http://www.w3.org/1999/xhtml">As mentioned in section <a shape="rect" href="chap48_mj.html#X8118FECE7AD1879B"><span class="RefLink">48.2</span></a>, we recommend to further simplify this presentation before you use it. The standard way to do this is to start from <math id="1879820662579921272" display="inline" alttext="P_{0}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msub xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">
      <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
      <mn xref="p1.1.m1.1.2.1.cmml" id="p1.1.m1.1.2.1">0</mn>
    </msub>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml">
        <csymbol id="p1.1.m1.1.3.1.cmml" cd="ambiguous">subscript</csymbol>
        <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
        <cn xref="p1.1.m1.1.2.1" id="p1.1.m1.1.2.1.cmml" type="integer">0</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P_{0}</annotation>
  </semantics>
</math> and to apply suitable Tietze transformations, e. g., by calling the commands <code class="func">TzGo</code> (<a shape="rect" href="chap48_mj.html#X7C4A30328224C466"><span class="RefLink">48.6-1</span></a>) or <code class="func">TzGoGo</code> (<a shape="rect" href="chap48_mj.html#X801D3D8984E1CA55"><span class="RefLink">48.6-3</span></a>). This is probably the most efficient approach, but you will end up with a presentation on some unpredictable set of generators. As an alternative, <strong class="pkg">GAP</strong> offers you the <code class="func">DecodeTree</code> command which you can use to eliminate all secondary generators (provided that there are no space or time problems). For this purpose, the subgroup presentation commands do not only return the resulting presentation, but also the tree (together with some associated lists) as a kind of side result in a component <var class="Arg">P</var><code class="code">!.tree</code> of the resulting presentation <var class="Arg">P</var>.</p><p xmlns="http://www.w3.org/1999/xhtml">Note, however, that the decoding tree routines will not work correctly any more on a presentation from which generators have already been eliminated by Tietze transformations. Therefore, to prevent you from getting wrong results by calling <code class="func">DecodeTree</code> in such a situation, <strong class="pkg">GAP</strong> will automatically remove the subgroup generators tree from a presentation as soon as one of the generators is substituted by a Tietze transformation.</p><p xmlns="http://www.w3.org/1999/xhtml">Nevertheless, a certain misuse of the command is still possible, and we want to explicitly warn you from this. The reason is that the Tietze option parameters described in Section <a shape="rect" href="chap48_mj.html#X856F37537E9927EE"><span class="RefLink">48.11</span></a> apply to <code class="func">DecodeTree</code> as well. Hence, in case of inadequate values of these parameters, it may happen that <code class="func">DecodeTree</code> stops before all the secondary generators have vanished. In this case <strong class="pkg">GAP</strong> will display an appropriate warning. Then you should change the respective parameters and continue the process by calling <code class="func">DecodeTree</code> again. Otherwise, if you would apply Tietze transformations, it might happen because of the convention described above that the tree is removed and that you end up with a wrong presentation.</p><p xmlns="http://www.w3.org/1999/xhtml">After a successful run of <code class="func">DecodeTree</code> it is convenient to further simplify the resulting presentation by suitable Tietze transformations.</p><p xmlns="http://www.w3.org/1999/xhtml">As an example of an explicit call of <code class="func">DecodeTree</code> we compute two presentations of a subgroup of order <math id="-6091180686452887987" display="inline" alttext="384" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mn xref="p1.1.m1.1.3.cmml" id="p1.1.m1.1.3">384</mn>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <cn xref="p1.1.m1.1.3" id="p1.1.m1.1.3.cmml" type="integer">384</cn>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">384</annotation>
  </semantics>
</math> in a group of order <math id="335708012666464228" display="inline" alttext="6912" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mn xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4">6912</mn>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <cn xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml" type="integer">6912</cn>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">6912</annotation>
  </semantics>
</math>. In both cases we use the Reduced Reidemeister-Schreier algorithm, but in the first run we just apply the Tietze transformations offered by the <code class="func">TzGoGo</code> (<a shape="rect" href="chap48_mj.html#X801D3D8984E1CA55"><span class="RefLink">48.6-3</span></a>) command with its default parameters, whereas in the second run we call the <code class="func">DecodeTree</code> command before.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F2 := FreeGroup( &quot;a&quot;, &quot;b&quot; );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := F2 / [ F2.1*F2.2^2*F2.1^-1*F2.2^-1*F2.1^3*F2.2^-1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               F2.2*F2.1^2*F2.2^-1*F2.1^-1*F2.2^3*F2.1^-1 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := G.1;;  b := G.2;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Subgroup( G, [ Comm(a^-1,b^-1), Comm(a^-1,b), Comm(a,b) ] );;</span>
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">We use the Reduced Reidemeister Schreier method and default Tietze transformations to get a presentation for <var class="Arg">H</var>.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PresentationSubgroupRrs( G, H );</span>
&lt;presentation with 18 gens and 35 rels of total length 169&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TzGoGo( P );</span>
#I  there are 3 generators and 20 relators of total length 488
#I  there are 3 generators and 20 relators of total length 466
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">We end up with 20 relators of total length 466. Now we repeat the procedure, but we call the decoding tree algorithm before doing the Tietze transformations.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PresentationSubgroupRrs( G, H );</span>
&lt;presentation with 18 gens and 35 rels of total length 169&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DecodeTree( P );</span>
#I  there are 9 generators and 26 relators of total length 185
#I  there are 6 generators and 23 relators of total length 213
#I  there are 3 generators and 20 relators of total length 252
#I  there are 3 generators and 20 relators of total length 244
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TzGoGo( P );</span>
#I  there are 3 generators and 19 relators of total length 168
#I  there are 3 generators and 17 relators of total length 138
#I  there are 3 generators and 15 relators of total length 114
#I  there are 3 generators and 13 relators of total length 96
#I  there are 3 generators and 12 relators of total length 84
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">This time we end up with a shorter presentation.</p><p xmlns="http://www.w3.org/1999/xhtml">As an example of an implicit call of the function <code class="func">DecodeTree</code> via the command <code class="func">PresentationSubgroupMtc</code> (<a shape="rect" href="chap48_mj.html#X80BA10F780EAE68E"><span class="RefLink">48.2-4</span></a>) we handle a subgroup of index 240 in a group of order 40320 given by a presentation due to B.¬†H.¬†Neumann. Note that we increase the level of <code class="func">InfoFpGroup</code> (<a shape="rect" href="chap47_mj.html#X8370BF3B78D0B14D"><span class="RefLink">47.1-3</span></a>) temporarily to get some additional output.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F3 := FreeGroup( &quot;a&quot;, &quot;b&quot;, &quot;c&quot; );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := F3.1;;  b := F3.2;;  c := F3.3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := F3 / [ a^3, b^3, c^3, (a*b)^5, (a^-1*b)^5, (a*c)^4,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    (a*c^-1)^4, a*b^-1*a*b*c^-1*a*c*a*c^-1, (b*c)^3, (b^-1*c)^4 ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := G.1;;  b := G.2;;  c := G.3;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Subgroup( G, [ a, c ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoFpGroup, 1 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := PresentationSubgroupMtc( G, H );;</span>
#I  index = 240  total = 4737  max = 4507
#I  MTC defined 2 primary and 4444 secondary subgroup generators
#I  there are 246 generators and 617 relators of total length 2893
#I  calling DecodeTree
#I  there are 114 generators and 385 relators of total length 1860
#I  there are 69 generators and 294 relators of total length 1855
#I  there are 43 generators and 235 relators of total length 2031
#I  there are 35 generators and 207 relators of total length 2348
#I  there are 25 generators and 181 relators of total length 3055
#I  there are 19 generators and 165 relators of total length 3290
#I  there are 20 generators and 160 relators of total length 5151
#I  there are 23 generators and 159 relators of total length 8177
#I  there are 25 generators and 159 relators of total length 12241
#I  there are 29 generators and 159 relators of total length 18242
#I  there are 34 generators and 159 relators of total length 27364
#I  there are 38 generators and 159 relators of total length 41480
#I  there are 41 generators and 159 relators of total length 62732
#I  there are 45 generators and 159 relators of total length 88872
#I  there are 46 generators and 159 relators of total length 111092
#I  there are 44 generators and 155 relators of total length 158181
#I  there are 32 generators and 155 relators of total length 180478
#I  there are 7 generators and 133 relators of total length 29897
#I  there are 4 generators and 119 relators of total length 28805
#I  there are 3 generators and 116 relators of total length 35209
#I  there are 2 generators and 111 relators of total length 25658
#I  there are 2 generators and 111 relators of total length 22634
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TzGoGo( P );</span>
#I  there are 2 generators and 108 relators of total length 11760
#I  there are 2 generators and 95 relators of total length 6482
#I  there are 2 generators and 38 relators of total length 1464
#I  there are 2 generators and 8 relators of total length 116
#I  there are 2 generators and 7 relators of total length 76
#I  there are 2 generators and 6 relators of total length 66
#I  there are 2 generators and 6 relators of total length 52
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TzPrintGenerators( P );</span>
#I  1.  _x1   26 occurrences
#I  2.  _x2   26 occurrences
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">TzPrint( P );</span>
#I  generators: [ _x1, _x2 ]
#I  relators:
#I  1.  3  [ 1, 1, 1 ]
#I  2.  3  [ 2, 2, 2 ]
#I  3.  8  [ 2, -1, 2, -1, 2, -1, 2, -1 ]
#I  4.  8  [ 2, 1, 2, 1, 2, 1, 2, 1 ]
#I  5.  14  [ -1, -2, 1, 2, 1, -2, -1, 2, 1, -2, -1, -2, 1, 2 ]
#I  6.  16  [ 1, 2, 1, -2, 1, 2, 1, -2, 1, 2, 1, -2, 1, 2, 1, -2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K :=  FpGroupPresentation( P );</span>
&lt;fp group on the generators [ _x1, _x2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoFpGroup, 0 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( K );</span>
168
</pre></div> </body>
    </html>