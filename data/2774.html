<html> 
      <head>
        <title>GAP (ref) - Chapter 39: Groups &amp;#8614; 39.21-1 LatticeByCyclicExtension</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap39_mj.html#X86462A567DDBA6BC"></meta>
      </head>
      <body> <h5 xmlns="http://www.w3.org/1999/xhtml">39.21-1 LatticeByCyclicExtension</h5><div class="func" xmlns="http://www.w3.org/1999/xhtml"><table width="100%" class="func"><tbody><tr><td colspan="1" rowspan="1" class="tdleft"><code class="func">â€£ LatticeByCyclicExtension</code>( <var class="Arg">G</var>[, <var class="Arg">func</var>[, <var class="Arg">noperf</var>]] )</td><td colspan="1" rowspan="1" class="tdright">( function )</td></tr></tbody></table></div><p xmlns="http://www.w3.org/1999/xhtml">computes the lattice of <var class="Arg">G</var> using the cyclic extension algorithm. If the function <var class="Arg">func</var> is given, the algorithm will discard all subgroups not fulfilling <var class="Arg">func</var> (and will also not extend them), returning a partial lattice. This can be useful to compute only subgroups with certain properties. Note however that this will <em>not</em> necessarily yield all subgroups that fulfill <var class="Arg">func</var>, but the subgroups whose subgroups are used for the construction must also fulfill <var class="Arg">func</var> as well. (In fact the filter <var class="Arg">func</var> will simply discard subgroups in the cyclic extension algorithm. Therefore the trivial subgroup will always be included.) Also note, that for such a partial lattice maximality/minimality inclusion relations cannot be computed. (If <var class="Arg">func</var> is a list of length 2, its first entry is such a discarding function, the second a function for discarding zuppos.)</p><p xmlns="http://www.w3.org/1999/xhtml">The cyclic extension algorithm requires the perfect subgroups of <var class="Arg">G</var>. However <strong class="pkg">GAP</strong> cannot analyze the function <var class="Arg">func</var> for its implication but can only apply it. If it is known that <var class="Arg">func</var> implies solvability, the computation of the perfect subgroups can be avoided by giving a third parameter <var class="Arg">noperf</var> set to <code class="keyw">true</code>.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=WreathProduct(Group((1,2,3),(1,2)),Group((1,2,3,4)));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l:=LatticeByCyclicExtension(g,function(G)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">return Size(G) in [1,2,3,6];end);</span>
&lt;subgroup lattice of &lt;permutation group of size 5184 with 
9 generators&gt;, 47 classes, 
2628 subgroups, restricted under further condition l!.func&gt;
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">The total number of classes in this example is much bigger, as the following example shows:</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LatticeSubgroups(g);</span>
&lt;subgroup lattice of &lt;permutation group of size 5184 with 
9 generators&gt;, 566 classes, 27134 subgroups&gt;
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">##</p> </body>
    </html>