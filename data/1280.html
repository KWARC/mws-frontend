<html> 
      <head>
        <title>GAP (ref) - Chapter 47: Finitely Presented Groups &amp;#8614; 47.11-2 IsomorphismFpGroupByGenerators</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap47_mj.html#X81B2B3B6812FD62D"></meta>
      </head>
      <body> <h5 xmlns="http://www.w3.org/1999/xhtml">47.11-2 IsomorphismFpGroupByGenerators</h5><div class="func" xmlns="http://www.w3.org/1999/xhtml"><table width="100%" class="func"><tbody><tr><td colspan="1" rowspan="1" class="tdleft"><code class="func">‚Ä£ IsomorphismFpGroupByGenerators</code>( <var class="Arg">G</var>, <var class="Arg">gens</var>[, <var class="Arg">string</var>] )</td><td colspan="1" rowspan="1" class="tdright">( function )</td></tr></tbody></table></div><div class="func" xmlns="http://www.w3.org/1999/xhtml"><table width="100%" class="func"><tbody><tr><td colspan="1" rowspan="1" class="tdleft"><code class="func">‚Ä£ IsomorphismFpGroupByGeneratorsNC</code>( <var class="Arg">G</var>, <var class="Arg">gens</var>, <var class="Arg">string</var> )</td><td colspan="1" rowspan="1" class="tdright">( operation )</td></tr></tbody></table></div><p xmlns="http://www.w3.org/1999/xhtml">returns an isomorphism from a finite group <var class="Arg">G</var> to a finitely presented group <var class="Arg">F</var> isomorphic to <var class="Arg">G</var>. The generators of <var class="Arg">F</var> correspond to the <em>generators of <var class="Arg">G</var> given in the list <var class="Arg">gens</var></em>. If <var class="Arg">string</var> is given it is used to name the generators of the finitely presented group.</p><p xmlns="http://www.w3.org/1999/xhtml">The <code class="code">NC</code> version will avoid testing whether the elements in <var class="Arg">gens</var> generate <var class="Arg">G</var>.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoFpGroup, 1 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismFpGroupByGenerators( g, [ (1,2), (1,2,3,4,5) ] );</span>
#I  the image group has 2 gens and 5 rels of total length 39
[ (1,2), (1,2,3,4,5) ] -&gt; [ F1, F2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fp := Image( iso );</span>
&lt;fp group of size 120 on the generators [ F1, F2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelatorsOfFpGroup( fp );</span>
[ F1^2, F2^5, (F2^-1*F1)^4, (F2*F1*F2^-1*F1)^3, (F2*F1*F2^-2*F1*F2)^2 
 ]
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">The main task of the function <code class="func">IsomorphismFpGroupByGenerators</code> is to find a presentation of <var class="Arg">G</var> in the provided generators <var class="Arg">gens</var>. In the case of a permutation group <var class="Arg">G</var> it does this by first constructing a stabilizer chain of <var class="Arg">G</var> and then it works through that chain from the bottom to the top, recursively computing a presentation for each of the involved stabilizers. The method used is essentially an implementation of John Cannon's multi-stage relations-finding algorithm as described in <a shape="rect" href="chapBib_mj.html#biBNeu82">[Neu82]</a> (see also <a shape="rect" href="chapBib_mj.html#biBCan73">[Can73]</a> for a more graph theoretical description). Moreover, it makes heavy use of Tietze transformations in each stage to avoid an explosion of the total length of the relators.</p><p xmlns="http://www.w3.org/1999/xhtml">Note that because of the random methods involved in the construction of the stabilizer chain the resulting presentations of <var class="Arg">G</var> will in general be different for repeated calls with the same arguments.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M12 := MathieuGroup( 12 );</span>
Group([ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6), 
  (1,12)(2,11)(3,6)(4,8)(5,9)(7,10) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := GeneratorsOfGroup( M12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismFpGroupByGenerators( M12, gens );;</span>
#I  the image group has 3 gens and 20 rels of total length 497
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismFpGroupByGenerators( M12, gens );;</span>
#I  the image group has 3 gens and 19 rels of total length 493
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Also in the case of a permutation group <var class="Arg">G</var>, the function <code class="func">IsomorphismFpGroupByGenerators</code> supports the option <code class="code">method</code> that can be used to modify the strategy. The option <code class="code">method</code> may take the following values.</p><dl xmlns="http://www.w3.org/1999/xhtml"><dt><strong class="Mark"><code class="code">method := &quot;regular&quot;</code></strong></dt><dd><p>This may be specified for groups of small size, up to <math id="-5668575060912627317" display="inline" alttext="10^{5}" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <msup xref="p1.1.m1.1.4.cmml" id="p1.1.m1.1.4">
      <mn xref="p1.1.m1.1.2.cmml" id="p1.1.m1.1.2">10</mn>
      <mn xref="p1.1.m1.1.3.1.cmml" id="p1.1.m1.1.3.1">5</mn>
    </msup>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <apply xref="p1.1.m1.1.4" id="p1.1.m1.1.4.cmml">
        <csymbol id="p1.1.m1.1.4.1.cmml" cd="ambiguous">superscript</csymbol>
        <cn xref="p1.1.m1.1.2" id="p1.1.m1.1.2.cmml" type="integer">10</cn>
        <cn xref="p1.1.m1.1.3.1" id="p1.1.m1.1.3.1.cmml" type="integer">5</cn>
      </apply>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">10^{5}</annotation>
  </semantics>
</math> say. It implies that the function first constructs a regular representation <var class="Arg">R</var> of <var class="Arg">G</var> and then a presentation of <var class="Arg">R</var>. In general, this presentation will be much more concise than the default one, but the price is the time needed for the construction of <var class="Arg">R</var>.</p>

</dd><dt><strong class="Mark"><code class="code">method := [ &quot;regular&quot;, bound ]</code></strong></dt><dd><p>This is a refinement of the previous possibility. In this case, <code class="code">bound</code> should be an integer, and if so the method <code class="code">&quot;regular&quot;</code> as described above is applied to the largest stabilizer in the stabilizer chain of <var class="Arg">G</var> whose size does not exceed the given bound and then the multi-stage algorithm is used to work through the chain from that subgroup to the top.</p>

</dd><dt><strong class="Mark"><code class="code">method := &quot;fast&quot;</code></strong></dt><dd><p>This chooses an alternative method which essentially is a kind of multi-stage algorithm for a stabilizer chain of <var class="Arg">G</var> but does not make any attempt do reduce the number of relators as it is done in Cannon's algorithm or to reduce their total length. Hence it is often much faster than the default method, but the total length of the resulting presentation may be huge.</p>

</dd><dt><strong class="Mark"><code class="code">method := &quot;default&quot;</code></strong></dt><dd><p>This simply means that the default method shall be used, which is the case if the option <code class="code">method</code> is not given a value.</p>

</dd></dl><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismFpGroupByGenerators( M12, gens : </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                          method := &quot;regular&quot; );;</span>
#I  the image group has 3 gens and 11 rels of total length 92
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismFpGroupByGenerators( M12, gens : </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                          method := &quot;fast&quot; );;</span>
#I  the image group has 3 gens and 151 rels of total length 3658
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Though the option <code class="code">method := &quot;regular&quot;</code> is only checked in the case of a permutation group it also affects the performance and the results of the function <code class="func">IsomorphismFpGroupByGenerators</code> for other groups, e. g. for matrix groups. This happens because, for these groups, the function first calls the function <code class="func">NiceMonomorphism</code> (<a shape="rect" href="chap40_mj.html#X7965086E82ABCF41"><span class="RefLink">40.5-2</span></a>) to get a bijective action homomorphism from <var class="Arg">G</var> to a suitable permutation group, <math id="7922802082650874292" display="inline" alttext="P" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P</annotation>
  </semantics>
</math> say, and then, recursively, calls itself for the group <math id="448016802063097307" display="inline" alttext="P" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">P</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">ùëÉ</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">P</annotation>
  </semantics>
</math> so that now the option becomes relevant.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ImfMatrixGroup( 5, 1, 3 );</span>
ImfMatrixGroup(5,1,3)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens := GeneratorsOfGroup( G );</span>
[ [ [ -1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 1, 0 ], 
      [ -1, -1, -1, -1, 2 ], [ -1, 0, 0, 0, 1 ] ], 
  [ [ 0, 1, 0, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ], 
      [ 1, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 1 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismFpGroupByGenerators( G, gens );;</span>
#I  the image group has 2 gens and 11 rels of total length 150
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := IsomorphismFpGroupByGenerators( G, gens : </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                                          method := &quot;regular&quot;);;</span>
#I  the image group has 2 gens and 6 rels of total length 56
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetInfoLevel( InfoFpGroup, 0 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso;</span>
&lt;composed isomorphism:[ [ [ -1, 0, 0, 0, 0 ], [ 0, 1, 0, 0, 0 ], [ 0, \
0, 0, 1, 0 ], [ -1, -1, -1, -1, 2 ], [ -1, 0, 0, 0, 1 ] ], [ [ 0, 1, 0\
, 0, 0 ], [ 0, 0, 1, 0, 0 ], [ 0, 0, 0, 1, 0 ], [ 1, 0, 0, 0, 0 ], [ 0\
, 0, 0, 0, 1 ] ] ]-&gt;[ F1, F2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ConstituentsCompositionMapping(iso);</span>
[ &lt;action isomorphism&gt;, 
  [ (2,3,4)(5,6)(8,9,10), (1,2,3,5)(6,7,8,9) ] -&gt; [ F1, F2 ] ]
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Since <strong class="pkg">GAP</strong> cannot decompose elements of a matrix group into generators, the resulting isomorphism is stored as a composition of a (faithful) permutation action on vectors and a homomorphism from the permutation image to the finitely presented group. In such a situation the constituent mappings can be obtained via <code class="func">ConstituentsCompositionMapping</code> (<a shape="rect" href="chap32_mj.html#X87775B438008DCA5"><span class="RefLink">32.2-7</span></a>) as separate <strong class="pkg">GAP</strong> objects.</p> </body>
    </html>