<html> 
      <head>
        <title>GAP (ref) - Chapter 31: Domains and their Elements &amp;#8614; 31.7-1 Parent</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap31_mj.html#X7BC856CC7F116BB0"></meta>
      </head>
      <body> <h5 xmlns="http://www.w3.org/1999/xhtml">31.7-1 Parent</h5><div class="func" xmlns="http://www.w3.org/1999/xhtml"><table width="100%" class="func"><tbody><tr><td colspan="1" rowspan="1" class="tdleft"><code class="func">‣ Parent</code>( <var class="Arg">D</var> )</td><td colspan="1" rowspan="1" class="tdright">( function )</td></tr></tbody></table></div><div class="func" xmlns="http://www.w3.org/1999/xhtml"><table width="100%" class="func"><tbody><tr><td colspan="1" rowspan="1" class="tdleft"><code class="func">‣ SetParent</code>( <var class="Arg">D</var>, <var class="Arg">P</var> )</td><td colspan="1" rowspan="1" class="tdright">( operation )</td></tr></tbody></table></div><div class="func" xmlns="http://www.w3.org/1999/xhtml"><table width="100%" class="func"><tbody><tr><td colspan="1" rowspan="1" class="tdleft"><code class="func">‣ HasParent</code>( <var class="Arg">D</var> )</td><td colspan="1" rowspan="1" class="tdright">( filter )</td></tr></tbody></table></div><p xmlns="http://www.w3.org/1999/xhtml">It is possible to assign to a domain <var class="Arg">D</var> one other domain <var class="Arg">P</var> containing <var class="Arg">D</var> as a subset, in order to exploit this subset relation between <var class="Arg">D</var> and <var class="Arg">P</var>. Note that <var class="Arg">P</var> need not have the same operational structure as <var class="Arg">D</var>, for example <var class="Arg">P</var> may be a magma and <var class="Arg">D</var> a field.</p><p xmlns="http://www.w3.org/1999/xhtml">The assignment is done by calling <code class="func">SetParent</code>, and <var class="Arg">P</var> is called the <em>parent</em> of <var class="Arg">D</var>. If <var class="Arg">D</var> has already a parent, calls to <code class="func">SetParent</code> will be ignored.</p><p xmlns="http://www.w3.org/1999/xhtml">If <var class="Arg">D</var> has a parent <var class="Arg">P</var> –this can be checked with <code class="func">HasParent</code>– then <var class="Arg">P</var> can be used to gain information about <var class="Arg">D</var>. First, the call of <code class="func">SetParent</code> causes <code class="func">UseSubsetRelation</code> (<a shape="rect" href="chap31_mj.html#X7C03098C838ADE40"><span class="RefLink">31.13-1</span></a>) to be called. Second, for a domain <var class="Arg">D</var> with parent, information relative to the parent can be stored in <var class="Arg">D</var>; for example, there is an attribute <code class="code">NormalizerInParent</code> for storing <code class="code">Normalizer( <var class="Arg">P</var>, <var class="Arg">D</var> )</code> in the case that <var class="Arg">D</var> is a group. (More about such parent dependent attributes can be found in <a shape="rect" href="chap85_mj.html#X78D4D0FF780C8A85"><span class="RefLink">85.2</span></a>.) Note that because of this relative information, one cannot change the parent; that is, one can set the parent only once, subsequent calls to <code class="func">SetParent</code> for the same domain <var class="Arg">D</var> are ignored. Further note that contrary to <code class="func">UseSubsetRelation</code> (<a shape="rect" href="chap31_mj.html#X7C03098C838ADE40"><span class="RefLink">31.13-1</span></a>), also knowledge about the parent <var class="Arg">P</var> might be used that is discovered after the <code class="func">SetParent</code> call.</p><p xmlns="http://www.w3.org/1999/xhtml">A stored parent can be accessed using <code class="func">Parent</code>. If <var class="Arg">D</var> has no parent then <code class="func">Parent</code> returns <var class="Arg">D</var> itself, and <code class="func">HasParent</code> will return <code class="keyw">false</code> also after a call to <code class="func">Parent</code>. So <code class="func">Parent</code> is <em>not</em> an attribute, the underlying attribute to store the parent is <code class="code">ParentAttr</code>.</p><p xmlns="http://www.w3.org/1999/xhtml">Certain functions that return domains with parent already set, for example <code class="func">Subgroup</code> (<a shape="rect" href="chap39_mj.html#X7C82AA387A42DCA0"><span class="RefLink">39.3-1</span></a>), are described in Section <a shape="rect" href="chap31_mj.html#X7B58FDEF80338DD6"><span class="RefLink">31.8</span></a>. Whenever a function has this property, the <strong class="pkg">GAP</strong> Reference Manual states this explicitly. Note that these functions <em>do not guarantee</em> a certain parent, for example <code class="func">DerivedSubgroup</code> (<a shape="rect" href="chap39_mj.html#X7CC17CF179ED7EF2"><span class="RefLink">39.12-3</span></a>) for a perfect group <math id="-634551676737981645" display="inline" alttext="G" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">G</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">𝐺</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">G</annotation>
  </semantics>
</math> may return <math id="-3213203184261597071" display="inline" alttext="G" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">G</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">𝐺</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">G</annotation>
  </semantics>
</math> itself, and if <math id="-3766414055620183647" display="inline" alttext="G" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">G</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">𝐺</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">G</annotation>
  </semantics>
</math> had already a parent then this is not replaced by <math id="-6452153457195092755" display="inline" alttext="G" class="ltx_Math" xmlns="http://www.w3.org/1998/Math/MathML">
  <semantics id="p1.1.m1.1a">
    <mi xref="p1.1.m1.1.1.cmml" id="p1.1.m1.1.1">G</mi>
    <annotation-xml id="p1.1.m1.1b" encoding="MathML-Content">
      <ci xref="p1.1.m1.1.1" id="p1.1.m1.1.1.cmml">𝐺</ci>
    </annotation-xml>
    <annotation id="p1.1.m1.1c" encoding="application/x-tex">G</annotation>
  </semantics>
</math>. As a rule of thumb, <strong class="pkg">GAP</strong> avoids to set a domain as its own parent, which is consistent with the behaviour of <code class="func">Parent</code>, at least until a parent is set explicitly with <code class="func">SetParent</code>.</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:= Group( (1,2,3), (1,2) );; h:= Group( (1,2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasParent( g );  HasParent( h );</span>
false
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetParent( h, g );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Parent( g );  Parent( h );</span>
Group([ (1,2,3), (1,2) ])
Group([ (1,2,3), (1,2) ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasParent( g );  HasParent( h );</span>
false
true
</pre></div> </body>
    </html>