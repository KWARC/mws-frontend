<html> 
      <head>
        <title>GAP (ref) - Chapter 80: Examples of Extending the System &amp;#8614; 80.1 Addition of a Method</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap80_mj.html#X7B42DF6E7CCF507D"></meta>
      </head>
      <body> <h4 xmlns="http://www.w3.org/1999/xhtml">80.1 <span class="Heading">Addition of a Method</span></h4><p xmlns="http://www.w3.org/1999/xhtml">The easiest case is the addition of a new algorithm as a method for an existing operation for the existing structures.</p><p xmlns="http://www.w3.org/1999/xhtml">For example, assume we wanted to implement a better method for computing the exponent of a nilpotent group (it is the product of the exponents of the Sylow subgroups).</p><p xmlns="http://www.w3.org/1999/xhtml">The first task is to find which operation is used by <strong class="pkg">GAP</strong> (it is <code class="func">Exponent</code> (<a shape="rect" href="chap39_mj.html#X7D44470C7DA59C1C"><span class="RefLink">39.16-2</span></a>)) and how it is declared. We can find this in the Reference Manual (in our particular case in section <a shape="rect" href="chap39_mj.html#X7F8264FA796B2B7D"><span class="RefLink">39.16</span></a>) and the declaration in the library file <code class="file">lib/grp.gd</code>. The easiest way to find the place of the declaration is usually to <code class="code">grep</code> over all <code class="code">.gd</code> and <code class="code">.g</code> files, see section <a shape="rect" href="chap83_mj.html#X848C952A87FB36E2"><span class="RefLink">83</span></a>.</p><p xmlns="http://www.w3.org/1999/xhtml">In our example the declaration in the library is:</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
DeclareAttribute(&quot;Exponent&quot;,IsGroup);
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Similarly we find that the filter <code class="func">IsNilpotentGroup</code> (<a shape="rect" href="chap39_mj.html#X87D062608719F2CD"><span class="RefLink">39.15-3</span></a>) represents the concept of being nilpotent.</p><p xmlns="http://www.w3.org/1999/xhtml">We then write a function that implements the new algorithm which takes the right set of arguments and install it as a method. In our example this installation would be:</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
InstallMethod(Exponent,&quot;for nilpotent groups&quot;,
  [IsGroup and IsNilpotent],
function(G)
  [function body omitted]
end);
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">We have left out the optional rank argument of <code class="func">InstallMethod</code> (<a shape="rect" href="chap78_mj.html#X837EFDAB7BEF290B"><span class="RefLink">78.2-1</span></a>), which normally is a wise choice –<strong class="pkg">GAP</strong> automatically uses an internal ranking based on the filters that is only offset by the given rank. So our method will certainly be regarded as &quot;better&quot; than a method that has been installed for mere groups or for solvable groups but will be ranked lower than the library method for abelian groups.</p><p xmlns="http://www.w3.org/1999/xhtml">That's all. Using <a shape="rect" href="chap7_mj.html#X80848FF486BD6F9F"><span class="RefLink">7.2-1</span></a> we can check for a nilpotent group that indeed our new method will be used.</p><p xmlns="http://www.w3.org/1999/xhtml">When testing, remember that the method selection will not check for properties that are not known. (This is done internally by checking the property tester first.) Therefore the method would not be applicable for the group <code class="code">g</code> in the following definition but only for the –mathematically identical but endowed with more knowledge by <strong class="pkg">GAP</strong>– group <code class="code">h</code>. (Section <a shape="rect" href="chap80_mj.html#X7D880DB779EBA8D5"><span class="RefLink">80.3</span></a> shows a way around this.)</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g:=Group((1,2),(1,3)(2,4));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">h:=Group((1,2),(1,3)(2,4));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsNilpotentGroup(h); # enforce test</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasIsNilpotentGroup(g);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HasIsNilpotentGroup(h);</span>
true
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">Let's now look at a slightly more complicated example: We want to implement a better method for computing normalizers in a nilpotent permutation group. (Such an algorithm can be found for example in <a shape="rect" href="chapBib_mj.html#biBluksrakocziwright97">[LRW97]</a>.)</p><p xmlns="http://www.w3.org/1999/xhtml">We already know <code class="func">IsNilpotentGroup</code> (<a shape="rect" href="chap39_mj.html#X87D062608719F2CD"><span class="RefLink">39.15-3</span></a>), the filter <code class="func">IsPermGroup</code> (<a shape="rect" href="chap43_mj.html#X7879877482F59676"><span class="RefLink">43.1-1</span></a>) represents the concept of being a group of permutations.</p><p xmlns="http://www.w3.org/1999/xhtml"><strong class="pkg">GAP</strong> uses <code class="func">Normalizer</code> (<a shape="rect" href="chap39_mj.html#X87B5370C7DFD401D"><span class="RefLink">39.11-1</span></a>) to compute normalizers, however the declaration is a bit more complicated. In the library we find</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
InParentFOA( &quot;Normalizer&quot;, IsGroup, IsObject, NewAttribute );
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">The full mechanism of <code class="func">InParentFOA</code> (<a shape="rect" href="chap85_mj.html#X7C0E62D8813A4EE6"><span class="RefLink">85.2-1</span></a>) is described in chapter <a shape="rect" href="chap85_mj.html#X8350247A8501969F"><span class="RefLink">85</span></a>, however for our purposes it is sufficient to know that for such a function the actual work is done by an operation <code class="code">NormalizerOp</code>, an underlying operation for <code class="func">Normalizer</code> (<a shape="rect" href="chap39_mj.html#X87B5370C7DFD401D"><span class="RefLink">39.11-1</span></a>) (and all the complications are just there to be able to remember certain results) and that the declaration of this operation is given by the first arguments, it would be:</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
DeclareOperation( &quot;NormalizerOp&quot;, [IsGroup, IsObject] );
</pre></div><p xmlns="http://www.w3.org/1999/xhtml">This time we decide to enter a non-default family predicate in the call to <code class="func">InstallMethod</code> (<a shape="rect" href="chap78_mj.html#X837EFDAB7BEF290B"><span class="RefLink">78.2-1</span></a>). We could just leave it out as in the previous call; this would yield the default value, the function <code class="func">ReturnTrue</code> (<a shape="rect" href="chap5_mj.html#X7DB422A2876CCC4D"><span class="RefLink">5.4-1</span></a>) of arbitrary many arguments which always returns <code class="keyw">true</code>. However, then the method might be called in some cases of inconsistent input (for example matrix groups in different characteristics) that ought to fall through the method selection to raise an error.</p><p xmlns="http://www.w3.org/1999/xhtml">In our situation, we want the second group to be a subgroup of the first, so necessarily both must have the same family and we can use <code class="func">IsIdenticalObj</code> (<a shape="rect" href="chap12_mj.html#X7961183378DFB902"><span class="RefLink">12.5-1</span></a>) as family predicate.</p><p xmlns="http://www.w3.org/1999/xhtml">Now we can install the method. Again this manual is lazy and does not show you the actual code:</p><div class="example" xmlns="http://www.w3.org/1999/xhtml"><pre xml:space="preserve">
InstallMethod(NormalizerOp,&quot;for nilpotent permutation groups&quot;,IsIdenticalObj,
  [IsPermGroup and IsNilpotentGroup,
   IsPermGroup and IsNilpotentGroup],
function(G,U)
  [ function body omitted ]
end);
</pre></div> </body>
    </html>