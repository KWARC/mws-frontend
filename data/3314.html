<html> 
      <head>
        <title>GAP (ref) - Chapter 80: Examples of Extending the System &amp;#8614; 80.7 Components versus Attributes</title>
        <meta name="url" content="http://www.gap-system.org/Manuals/doc/ref/chap80_mj.html#X86AA65D4815CAE95"></meta>
      </head>
      <body> <h4 xmlns="http://www.w3.org/1999/xhtml">80.7 <span class="Heading">Components versus Attributes</span></h4><p xmlns="http://www.w3.org/1999/xhtml">In the last section we introduced two new components, <code class="code">G!.degree</code> and <code class="code">G!.relations</code>. Technically, we could have used attributes instead. There is no clear distinction which variant is to be preferred: An attribute expresses part of the functionality available to certain objects (and thus could be computed later and probably even for a wider class of objects), a component is just part of the internal definition of an object.</p><p xmlns="http://www.w3.org/1999/xhtml">So if the data is &quot;of general interest&quot;, if we want the user to have access to it, attributes are preferable. Moreover, attributes can be used by the method selection (by specifying the filter <code class="code">HasAttr</code> for an attribute <code class="code">Attr</code>). They provide a clean interface and their immutability makes it safe to hand the data to a user who potentially could corrupt a components entries.</p><p xmlns="http://www.w3.org/1999/xhtml">On the other hand more &quot;technical&quot; data (say the encoding of a sparse matrix) is better hidden from the user in a component, as declaring it as an attribute would not give any advantage.</p><p xmlns="http://www.w3.org/1999/xhtml">Resource-wise, attributes need more memory (the attribute setter and tester are implicitly declared, and one filter bit is required), the attribute access is one further function call in the kernel, thus components might be an immeasurable bit faster.</p> </body>
    </html>